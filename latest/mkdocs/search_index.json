{
    "docs": [
        {
            "location": "/", 
            "text": "RNG.jl Documentation\n\n\nRNG.jl\n is a collection of Random Number Generators for the Julia language.\n\n\nThere are several kinds of RNG families in this package, provided as submodules.\n\n\nThe examples and detailed descriptions of each RNG can be found on the Manual pages.\n\n\n\n\nManual Outline\n\n\n\n\nBases\n\n\nInstallation\n\n\nInterface\n\n\nEmpirical Statistical Testing\n\n\nConversion to Float\n\n\n\n\n\n\nPermuted Congruential Generators\n\n\nMersenne Twisters\n\n\nRandom123 Family\n\n\nXorshift Family\n\n\n\n\n\n\nLibrary Outline\n\n\n\n\nRNG\n\n\nIndex\n\n\nPublic\n\n\nInternal\n\n\n\n\n\n\nPCG\n\n\nIndex\n\n\nPublic\n\n\nInternal\n\n\n\n\n\n\nMersenneTwisters\n\n\nIndex\n\n\nPublic\n\n\nInternal\n\n\n\n\n\n\nRandom123\n\n\nIndex\n\n\nPublic\n\n\nInternal\n\n\n\n\n\n\nXorshifts\n\n\nIndex\n\n\nPublic\n\n\nInternal", 
            "title": "Home"
        }, 
        {
            "location": "/#rngjl-documentation", 
            "text": "RNG.jl  is a collection of Random Number Generators for the Julia language.  There are several kinds of RNG families in this package, provided as submodules.  The examples and detailed descriptions of each RNG can be found on the Manual pages.", 
            "title": "RNG.jl Documentation"
        }, 
        {
            "location": "/#manual-outline", 
            "text": "Bases  Installation  Interface  Empirical Statistical Testing  Conversion to Float    Permuted Congruential Generators  Mersenne Twisters  Random123 Family  Xorshift Family", 
            "title": "Manual Outline"
        }, 
        {
            "location": "/#library-outline", 
            "text": "RNG  Index  Public  Internal    PCG  Index  Public  Internal    MersenneTwisters  Index  Public  Internal    Random123  Index  Public  Internal    Xorshifts  Index  Public  Internal", 
            "title": "Library Outline"
        }, 
        {
            "location": "/man/bases/", 
            "text": "Bases\n\n\nThis page describes basic concepts and fundanmental knowledge of \nRNG.jl\n.\n\n\n\n\nNote\n\n\nUnless otherwise specified, all the random number generators in this package are \npseudorandom\n number generators (or \ndeterministic\n random bit generator), which means they only provide numbers whose properties approximate the properties of \ntruly random\n numbers. Always, especially in secure-sensitive cases, keep in mind that they do not gaurantee a totally random performance.\n\n\n\n\n\n\nInstallation\n\n\nThis package is currently not registered, so you have to directly clone it for installation:\n\n\njulia\n \nPkg\n.\nclone\n(\nhttps://github.com/sunoru/RNG.jl.git\n)\n\n\n\n\n\n\nAnd build the dependencies:\n\n\njulia\n \nPkg\n.\nbuild\n(\nRNG\n)\n\n\n\n\n\n\nIt is recommended to run the test suites before using the package:\n\n\njulia\n \nPkg\n.\ntest\n(\nRNG\n)\n\n\n\n\n\n\n\n\nInterface\n\n\nFirst of all, to use a RNG from this package, you can import \nRNG.jl\n and use RNG by declare its submodule's name, or directly import the submodule. Then you can create a random number generator of certain type. For example:\n\n\njulia\n \nusing\n \nRNG\n\n\njulia\n \nr\n \n=\n \nXorshifts\n.\nXorshift1024Plus\n()\n\n\n\n\n\n\nor\n\n\njulia\n \nusing\n \nRNG\n.\nXorshifts\n\n\njulia\n \nr\n \n=\n \nXorshift1024Plus\n()\n\n\n\n\n\n\nThe submodules have some API in common and a few differently.\n\n\nAll the Random Number Generators (RNGs) are child types of \nAbstractRNG{T}\n, which is a child type of \nBase.Random.AbstractRNG\n and replaces it. (\nBase.Random\n may be refactored sometime, anyway.) The type parameter \nT\n indicates the original output type of a RNG, and it is usually a child type of \nUnsigned\n, such as \nUInt64\n, \nUInt32\n, etc. Users can change the output type of a certain RNG type by use a wrapped type: \nWrappedRNG\n.\n\n\nConsistent to what \nBase.Random\n does, there are generic functions:\n\n\n\n\nsrand(::AbstractRNG{T}[, seed])\n   initializes a RNG by one or a sequence of numbers (called \nseed\n). The output sequences by two RNGs of   the same type should be the same if they are initialized by the same seed, which makes them   \ndeterministic\n. The seed type of each RNG type can be different, you can refer to the corresponding   manual pages for details. If no \nseed\n provided, then it will use \nRNG.gen_seed\n to get a \"truly\"   random one.\n\n\nrand(::AbstractRNG{T}[, ::Type{TP}=Float64])\n   returns a random number in the type \nTP\n. \nTP\n is usually an \nUnsigned\n type, and the return value is   expected to be uniformly distributed in {0, 1} at every bit. When \nTP\n is \nFloat64\n (as default), this   function returns a \nFloat64\n value that is expected to be uniformly distributed in $[0, 1)$. The discussion   about this is in the \nConversion to Float\n section.\n\n\n\n\nThe other generic functions such as \nrand(::AbstractRNG, ::Dims)\n and \nrand!(::AbstractRNG, ::AbstractArray)\n defined in \nBase.Random\n still work.\n\n\nThe constructors of all the types of RNG are designed to take the same kind of parameters as \nsrand\n. For example:\n\n\njulia\n \nusing\n \nRNG\n.\nXorshifts\n\n\n\njulia\n \nr1\n \n=\n \nXorshift128Star\n(\n123\n)\n  \n# Create a RNG of Xorshift128Star with the seed \n123\n\n\nRNG.Xorshifts.Xorshift128Star(0x000000003a300074,0x000000003a30004e)\n\n\n\njulia\n \nr2\n \n=\n \nXorshift128Star\n();\n  \n# Use a random value to be the seed.\n\n\n\njulia\n \nrand\n(\nr1\n)\n  \n# Generate a number uniformly distributed in ``[0, 1)``.\n\n\n0.2552720033868119\n\n\n\njulia\n \nA\n \n=\n \nrand\n(\nr1\n,\n \nUInt64\n,\n \n2\n,\n \n3\n)\n  \n# Generate a 2x3 matrix `A` in `UInt64` type.\n\n\n2\u00d73 Array{UInt64,2}:\n\n\n 0xbed3dea863c65407  0x607f5f9815f515af  0x807289d8f9847407\n\n\n 0x4ab80d43269335ee  0xf78b56ada11ea641  0xc2306a55acfb4aaa\n\n\n\njulia\n \nrand!\n(\nr1\n,\n \nA\n)\n  \n# Refill `A` with random numbers.\n\n\n2\u00d73 Array{UInt64,2}:\n\n\n 0xf729352e2a72b541  0xe89948b5582a85f0  0x8a95ebd6aa34fcf4\n\n\n 0xc0c5a8df4c1b160f  0x8b5269ed6c790e08  0x930b89985ae0c865\n\n\n\n\n\n\nPeople will get the same results in their own computers of the above lines. For more interfaces and usage examples, please refer to the manual pages of each RNG.\n\n\n\n\nEmpirical Statistical Testing\n\n\nEmpirical statistical testing is very important for random number generation, because the theoretical mathematical analysis is insufficient to verify the performance of a random number generator.\n\n\nThe famous and highly evaluated \nTestU01\n library\n is chosen to test the RNGs in \nRNG.jl\n. \nTestU01\n offers a collection of test suites, and \nBig Crush\n is the largest and most stringent test battery for empirical testing (which usually takes several hours to run). \nBig Crush\n has revealed a number of flaws of lots of well-used generators, even including the \nMersenne Twister\n (or to be more exact, the \ndSFMT\n) which is currently used in \nBase.Random\n as \nGLOBAL_RAND\n.\n1\n\n\nThe testing results are available on \nBenchmark\n page.\n\n\n\n\nConversion to Float\n\n\nBesides the statistical flaws, popular generators often neglect the importance of converting unsigned integers to floating numbers. The most common situation is to convert an \nUInt\n to a \nFloat64\n which is uniformly distributed in $[0.0, 1.0)$. For example, neither the \nstd::uniform_real_distribution\n in libstdc++ from gcc, libc++ from llvm, nor the standard library from MSVC has a correct performance, as they all have a non-zero probability for generating the max value which is an open bound and should not be produced.\n\n\nThe cause is that a \nFloat64\n number in $[0.0, 1.0)$ has only 53 \nsignificand\n bits (52 explicitly stored), which means at least 11 bits of an \nUInt64\n are abandoned when being converted to \nFloat64\n. If using the naive approach to multiply an \nUInt64\n by $2^{-64}$, users may get 1.0, and the distribution is not good (although using $2^{-32}$ for an \nUInt32\n is OK).\n\n\nIn this package, we make use of the fact that the distribution of the least 52 bits can be the same in an \nUInt64\n and a \nFloat64\n (if you are familiar with \nIEEE 754\n this is easy to understand). An \nUInt64\n will firstly be converted to a \nFloat64\n that is perfectly uniformly distributed in [1.0, 2.0), and then be minus by one. This is a very fast approach, but not completely ideal, since the one bit is wasted. The current default RNG in \nBase.Random\n library does the same thing, so it also causes some tricky problems.\n2\n\n\n\n\n\n\n\n\n\n\nrand\n fails bigcrush #6464\n\n\n\n\n\n\nLeast significant bit of rand() is always zero #16344", 
            "title": "Bases"
        }, 
        {
            "location": "/man/bases/#bases", 
            "text": "This page describes basic concepts and fundanmental knowledge of  RNG.jl .   Note  Unless otherwise specified, all the random number generators in this package are  pseudorandom  number generators (or  deterministic  random bit generator), which means they only provide numbers whose properties approximate the properties of  truly random  numbers. Always, especially in secure-sensitive cases, keep in mind that they do not gaurantee a totally random performance.", 
            "title": "Bases"
        }, 
        {
            "location": "/man/bases/#installation", 
            "text": "This package is currently not registered, so you have to directly clone it for installation:  julia   Pkg . clone ( https://github.com/sunoru/RNG.jl.git )   And build the dependencies:  julia   Pkg . build ( RNG )   It is recommended to run the test suites before using the package:  julia   Pkg . test ( RNG )", 
            "title": "Installation"
        }, 
        {
            "location": "/man/bases/#interface", 
            "text": "First of all, to use a RNG from this package, you can import  RNG.jl  and use RNG by declare its submodule's name, or directly import the submodule. Then you can create a random number generator of certain type. For example:  julia   using   RNG  julia   r   =   Xorshifts . Xorshift1024Plus ()   or  julia   using   RNG . Xorshifts  julia   r   =   Xorshift1024Plus ()   The submodules have some API in common and a few differently.  All the Random Number Generators (RNGs) are child types of  AbstractRNG{T} , which is a child type of  Base.Random.AbstractRNG  and replaces it. ( Base.Random  may be refactored sometime, anyway.) The type parameter  T  indicates the original output type of a RNG, and it is usually a child type of  Unsigned , such as  UInt64 ,  UInt32 , etc. Users can change the output type of a certain RNG type by use a wrapped type:  WrappedRNG .  Consistent to what  Base.Random  does, there are generic functions:   srand(::AbstractRNG{T}[, seed])    initializes a RNG by one or a sequence of numbers (called  seed ). The output sequences by two RNGs of   the same type should be the same if they are initialized by the same seed, which makes them    deterministic . The seed type of each RNG type can be different, you can refer to the corresponding   manual pages for details. If no  seed  provided, then it will use  RNG.gen_seed  to get a \"truly\"   random one.  rand(::AbstractRNG{T}[, ::Type{TP}=Float64])    returns a random number in the type  TP .  TP  is usually an  Unsigned  type, and the return value is   expected to be uniformly distributed in {0, 1} at every bit. When  TP  is  Float64  (as default), this   function returns a  Float64  value that is expected to be uniformly distributed in $[0, 1)$. The discussion   about this is in the  Conversion to Float  section.   The other generic functions such as  rand(::AbstractRNG, ::Dims)  and  rand!(::AbstractRNG, ::AbstractArray)  defined in  Base.Random  still work.  The constructors of all the types of RNG are designed to take the same kind of parameters as  srand . For example:  julia   using   RNG . Xorshifts  julia   r1   =   Xorshift128Star ( 123 )    # Create a RNG of Xorshift128Star with the seed  123  RNG.Xorshifts.Xorshift128Star(0x000000003a300074,0x000000003a30004e)  julia   r2   =   Xorshift128Star ();    # Use a random value to be the seed.  julia   rand ( r1 )    # Generate a number uniformly distributed in ``[0, 1)``.  0.2552720033868119  julia   A   =   rand ( r1 ,   UInt64 ,   2 ,   3 )    # Generate a 2x3 matrix `A` in `UInt64` type.  2\u00d73 Array{UInt64,2}:   0xbed3dea863c65407  0x607f5f9815f515af  0x807289d8f9847407   0x4ab80d43269335ee  0xf78b56ada11ea641  0xc2306a55acfb4aaa  julia   rand! ( r1 ,   A )    # Refill `A` with random numbers.  2\u00d73 Array{UInt64,2}:   0xf729352e2a72b541  0xe89948b5582a85f0  0x8a95ebd6aa34fcf4   0xc0c5a8df4c1b160f  0x8b5269ed6c790e08  0x930b89985ae0c865   People will get the same results in their own computers of the above lines. For more interfaces and usage examples, please refer to the manual pages of each RNG.", 
            "title": "Interface"
        }, 
        {
            "location": "/man/bases/#empirical-statistical-testing", 
            "text": "Empirical statistical testing is very important for random number generation, because the theoretical mathematical analysis is insufficient to verify the performance of a random number generator.  The famous and highly evaluated  TestU01  library  is chosen to test the RNGs in  RNG.jl .  TestU01  offers a collection of test suites, and  Big Crush  is the largest and most stringent test battery for empirical testing (which usually takes several hours to run).  Big Crush  has revealed a number of flaws of lots of well-used generators, even including the  Mersenne Twister  (or to be more exact, the  dSFMT ) which is currently used in  Base.Random  as  GLOBAL_RAND . 1  The testing results are available on  Benchmark  page.", 
            "title": "Empirical Statistical Testing"
        }, 
        {
            "location": "/man/bases/#conversion-to-float", 
            "text": "Besides the statistical flaws, popular generators often neglect the importance of converting unsigned integers to floating numbers. The most common situation is to convert an  UInt  to a  Float64  which is uniformly distributed in $[0.0, 1.0)$. For example, neither the  std::uniform_real_distribution  in libstdc++ from gcc, libc++ from llvm, nor the standard library from MSVC has a correct performance, as they all have a non-zero probability for generating the max value which is an open bound and should not be produced.  The cause is that a  Float64  number in $[0.0, 1.0)$ has only 53  significand  bits (52 explicitly stored), which means at least 11 bits of an  UInt64  are abandoned when being converted to  Float64 . If using the naive approach to multiply an  UInt64  by $2^{-64}$, users may get 1.0, and the distribution is not good (although using $2^{-32}$ for an  UInt32  is OK).  In this package, we make use of the fact that the distribution of the least 52 bits can be the same in an  UInt64  and a  Float64  (if you are familiar with  IEEE 754  this is easy to understand). An  UInt64  will firstly be converted to a  Float64  that is perfectly uniformly distributed in [1.0, 2.0), and then be minus by one. This is a very fast approach, but not completely ideal, since the one bit is wasted. The current default RNG in  Base.Random  library does the same thing, so it also causes some tricky problems. 2      rand  fails bigcrush #6464    Least significant bit of rand() is always zero #16344", 
            "title": "Conversion to Float"
        }, 
        {
            "location": "/man/benchmark/", 
            "text": "Benchmark", 
            "title": "Benchmark"
        }, 
        {
            "location": "/man/benchmark/#benchmark", 
            "text": "", 
            "title": "Benchmark"
        }, 
        {
            "location": "/man/pcg/", 
            "text": "Permuted Congruential Generators", 
            "title": "PCG Family"
        }, 
        {
            "location": "/man/pcg/#permuted-congruential-generators", 
            "text": "", 
            "title": "Permuted Congruential Generators"
        }, 
        {
            "location": "/man/mersenne-twisters/", 
            "text": "Mersenne Twisters\n\n\nMersenne Twisters are", 
            "title": "Mersenne Twisters"
        }, 
        {
            "location": "/man/mersenne-twisters/#mersenne-twisters", 
            "text": "Mersenne Twisters are", 
            "title": "Mersenne Twisters"
        }, 
        {
            "location": "/man/random123/", 
            "text": "Random123 Family", 
            "title": "Random123 Family"
        }, 
        {
            "location": "/man/random123/#random123-family", 
            "text": "", 
            "title": "Random123 Family"
        }, 
        {
            "location": "/man/xorshifts/", 
            "text": "Xorshift Family", 
            "title": "Xorshift Family"
        }, 
        {
            "location": "/man/xorshifts/#xorshift-family", 
            "text": "", 
            "title": "Xorshift Family"
        }, 
        {
            "location": "/man/ref/", 
            "text": "Reference", 
            "title": "Reference"
        }, 
        {
            "location": "/man/ref/#reference", 
            "text": "", 
            "title": "Reference"
        }, 
        {
            "location": "/lib/rng/", 
            "text": "RNG\n\n\n\n\nIndex\n\n\n\n\nRNG\n\n\nRNG.AbstractRNG\n\n\nRNG.WrappedRNG\n\n\nRNG.gen_seed\n\n\nRNG.output_type\n\n\n\n\n\n\nPublic\n\n\n#\n\n\nRNG\n \n \nModule\n.\n\n\nMain module for \nRNG.jl\n \u2013 a random number generator package for Julia Language.\n\n\nThis module exports two types and four submodules:\n\n\n\n\nAbstractRNG\n.\n\n\nWrappedRNG\n.\n\n\nPCG\n.\n\n\nMersenneTwisters\n.\n\n\nRandom123\n.\n\n\nXorshifts\n.\n\n\n\n\nsource\n\n\n#\n\n\nRNG.AbstractRNG\n \n \nType\n.\n\n\nAbstractRNG\n{\nT\n}\n \n:\n \nBase\n.\nRandom\n.\nAbstractRNG\n\n\n\n\n\n\nThe abstract type of Random Number Generators. T indicates the original output type of a RNG.\n\n\nsource\n\n\n#\n\n\nRNG.WrappedRNG\n \n \nType\n.\n\n\nWrappedRNG\n{\nR\n,\n \nT1\n,\n \nT2\n}\n \n:\n \nAbstractRNG\n{\nT2\n}\n\n\nWrappedRNG\n(\nbase_rng\n,\n \nT2\n)\n\n\nWrappedRNG\n(\nR\n,\n \nT2\n,\n \nargs\n...\n)\n\n\n\n\n\n\nWrap a RNG which originally provides output in T1 into a RNG that provides output in T2.\n\n\nExamples\n\n\njulia\n \nr\n \n=\n \nXorshifts\n.\nXorshift128Star\n(\n123\n);\n\n\n\njulia\n \nRNG\n.\noutput_type\n(\nr\n)\n\n\nUInt64\n\n\n\njulia\n \nr1\n \n=\n \nWrappedRNG\n(\nr\n,\n \nUInt32\n);\n\n\n\njulia\n \nRNG\n.\noutput_type\n(\nr1\n)\n\n\nUInt32\n\n\n\njulia\n \nr2\n \n=\n \nWrappedRNG\n(\nXorshifts\n.\nXorshift128Star\n,\n \nUInt32\n,\n \n123\n);\n\n\n\njulia\n \nRNG\n.\noutput_type\n(\nr2\n)\n\n\nUInt32\n\n\n\njulia\n \n@\nTest\n.\ntest\n \nrand\n(\nr1\n,\n \nUInt32\n,\n \n3\n)\n \n==\n \nrand\n(\nr2\n,\n \nUInt32\n,\n \n3\n)\n\n\nTest Passed\n\n\n  Expression: rand(r1,UInt32,3) == rand(r2,UInt32,3)\n\n\n   Evaluated: UInt32[0x18a21796,0x20241598,0x63c65407] == UInt32[0x18a21796,0x20241598,0x63c65407]\n\n\n\n\n\n\nsource\n\n\n\n\nInternal\n\n\n#\n\n\nRNG.gen_seed\n \n \nMethod\n.\n\n\ngen_seed\n(\nT\n[,\n \nn\n])\n\n\n\n\n\n\nGenerate a tuple of \nn\n truly random numbers in type \nT\n. If \nn\n is missing, return only one number. The \"truly\" random numbers are provided by the random device of system. See \nBase.Random.RandomDevice\n.\n\n\nExamples\n\n\njulia\n \nRNG\n.\ngen_seed\n(\nUInt64\n,\n \n2\n)\n  \n# The output should probably be different on different computers.\n\n\n(\n0x26aa3fe5e306f725\n,\n0x7b9dc3c227d8acc9\n)\n\n\n\njulia\n \nRNG\n.\ngen_seed\n(\nUInt32\n)\n\n\n0x9ba60fdc\n\n\n\n\n\n\nsource\n\n\n#\n\n\nRNG.output_type\n \n \nMethod\n.\n\n\nGet the original output type of a RNG.\n\n\nsource", 
            "title": "RNG"
        }, 
        {
            "location": "/lib/rng/#rng", 
            "text": "", 
            "title": "RNG"
        }, 
        {
            "location": "/lib/rng/#index", 
            "text": "RNG  RNG.AbstractRNG  RNG.WrappedRNG  RNG.gen_seed  RNG.output_type", 
            "title": "Index"
        }, 
        {
            "location": "/lib/rng/#public", 
            "text": "#  RNG     Module .  Main module for  RNG.jl  \u2013 a random number generator package for Julia Language.  This module exports two types and four submodules:   AbstractRNG .  WrappedRNG .  PCG .  MersenneTwisters .  Random123 .  Xorshifts .   source  #  RNG.AbstractRNG     Type .  AbstractRNG { T }   :   Base . Random . AbstractRNG   The abstract type of Random Number Generators. T indicates the original output type of a RNG.  source  #  RNG.WrappedRNG     Type .  WrappedRNG { R ,   T1 ,   T2 }   :   AbstractRNG { T2 }  WrappedRNG ( base_rng ,   T2 )  WrappedRNG ( R ,   T2 ,   args ... )   Wrap a RNG which originally provides output in T1 into a RNG that provides output in T2.  Examples  julia   r   =   Xorshifts . Xorshift128Star ( 123 );  julia   RNG . output_type ( r )  UInt64  julia   r1   =   WrappedRNG ( r ,   UInt32 );  julia   RNG . output_type ( r1 )  UInt32  julia   r2   =   WrappedRNG ( Xorshifts . Xorshift128Star ,   UInt32 ,   123 );  julia   RNG . output_type ( r2 )  UInt32  julia   @ Test . test   rand ( r1 ,   UInt32 ,   3 )   ==   rand ( r2 ,   UInt32 ,   3 )  Test Passed    Expression: rand(r1,UInt32,3) == rand(r2,UInt32,3)     Evaluated: UInt32[0x18a21796,0x20241598,0x63c65407] == UInt32[0x18a21796,0x20241598,0x63c65407]   source", 
            "title": "Public"
        }, 
        {
            "location": "/lib/rng/#internal", 
            "text": "#  RNG.gen_seed     Method .  gen_seed ( T [,   n ])   Generate a tuple of  n  truly random numbers in type  T . If  n  is missing, return only one number. The \"truly\" random numbers are provided by the random device of system. See  Base.Random.RandomDevice .  Examples  julia   RNG . gen_seed ( UInt64 ,   2 )    # The output should probably be different on different computers.  ( 0x26aa3fe5e306f725 , 0x7b9dc3c227d8acc9 )  julia   RNG . gen_seed ( UInt32 )  0x9ba60fdc   source  #  RNG.output_type     Method .  Get the original output type of a RNG.  source", 
            "title": "Internal"
        }, 
        {
            "location": "/lib/pcg/", 
            "text": "PCG\n\n\n\n\nIndex\n\n\n\n\nRNG.PCG\n\n\nRNG.PCG.PCGMethod\n\n\nRNG.PCG.PCG_LIST\n\n\nRNG.PCG.AbstractPCG\n\n\nRNG.PCG.PCGStateMCG\n\n\nRNG.PCG.PCGStateOneseq\n\n\nRNG.PCG.PCGStateSetseq\n\n\nRNG.PCG.PCGStateUnique\n\n\nRNG.PCG.advance!\n\n\nRNG.PCG.bounded_rand\n\n\nRNG.PCG.default_increment\n\n\nRNG.PCG.default_multiplier\n\n\nRNG.PCG.mcg_multiplier\n\n\nRNG.PCG.mcg_unmultiplier\n\n\nRNG.PCG.pcg_advance!\n\n\nRNG.PCG.pcg_advance_lcg\n\n\nRNG.PCG.pcg_output\n\n\nRNG.PCG.pcg_srand\n\n\nRNG.PCG.pcg_step!\n\n\n\n\n\n\nPublic\n\n\n#\n\n\nRNG.PCG\n \n \nModule\n.\n\n\nThe module for \nRandom123 Family\n.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.PCGMethod\n \n \nConstant\n.\n\n\nThe \nUnion\n of all the PCG method types: \nPCG_XSH_RS\n, \nPCG_XSH_RR\n, \nPCG_RXS_M_XS\n, \nPCG_XSL_RR\n, and \nPCG_XSL_RR_RR\n.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.PCG_LIST\n \n \nConstant\n.\n\n\nThe list of all the parameter combinations that can be used for PCG.\n\n\n\n\n\n\n\n\nStream variation\n\n\nState Type\n\n\nMethod Type\n\n\nOutput Type\n\n\n\n\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt16\n\n\nPCG_XSH_RS\n\n\nUInt8\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt32\n\n\nPCG_XSH_RS\n\n\nUInt16\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt64\n\n\nPCG_XSH_RS\n\n\nUInt32\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt128\n\n\nPCG_XSH_RS\n\n\nUInt64\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt16\n\n\nPCG_XSH_RS\n\n\nUInt8\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt32\n\n\nPCG_XSH_RS\n\n\nUInt16\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt64\n\n\nPCG_XSH_RS\n\n\nUInt32\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt128\n\n\nPCG_XSH_RS\n\n\nUInt64\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt16\n\n\nPCG_XSH_RS\n\n\nUInt8\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt32\n\n\nPCG_XSH_RS\n\n\nUInt16\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt64\n\n\nPCG_XSH_RS\n\n\nUInt32\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt128\n\n\nPCG_XSH_RS\n\n\nUInt64\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt16\n\n\nPCG_XSH_RS\n\n\nUInt8\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt32\n\n\nPCG_XSH_RS\n\n\nUInt16\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt64\n\n\nPCG_XSH_RS\n\n\nUInt32\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt128\n\n\nPCG_XSH_RS\n\n\nUInt64\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt16\n\n\nPCG_XSH_RR\n\n\nUInt8\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt32\n\n\nPCG_XSH_RR\n\n\nUInt16\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt64\n\n\nPCG_XSH_RR\n\n\nUInt32\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt128\n\n\nPCG_XSH_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt16\n\n\nPCG_XSH_RR\n\n\nUInt8\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt32\n\n\nPCG_XSH_RR\n\n\nUInt16\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt64\n\n\nPCG_XSH_RR\n\n\nUInt32\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt128\n\n\nPCG_XSH_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt16\n\n\nPCG_XSH_RR\n\n\nUInt8\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt32\n\n\nPCG_XSH_RR\n\n\nUInt16\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt64\n\n\nPCG_XSH_RR\n\n\nUInt32\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt128\n\n\nPCG_XSH_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt16\n\n\nPCG_XSH_RR\n\n\nUInt8\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt32\n\n\nPCG_XSH_RR\n\n\nUInt16\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt64\n\n\nPCG_XSH_RR\n\n\nUInt32\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt128\n\n\nPCG_XSH_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt8\n\n\nPCG_RXS_M_XS\n\n\nUInt8\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt16\n\n\nPCG_RXS_M_XS\n\n\nUInt16\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt32\n\n\nPCG_RXS_M_XS\n\n\nUInt32\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt64\n\n\nPCG_RXS_M_XS\n\n\nUInt64\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt128\n\n\nPCG_RXS_M_XS\n\n\nUInt128\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt16\n\n\nPCG_RXS_M_XS\n\n\nUInt16\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt32\n\n\nPCG_RXS_M_XS\n\n\nUInt32\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt64\n\n\nPCG_RXS_M_XS\n\n\nUInt64\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt128\n\n\nPCG_RXS_M_XS\n\n\nUInt128\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt8\n\n\nPCG_RXS_M_XS\n\n\nUInt8\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt16\n\n\nPCG_RXS_M_XS\n\n\nUInt16\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt32\n\n\nPCG_RXS_M_XS\n\n\nUInt32\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt64\n\n\nPCG_RXS_M_XS\n\n\nUInt64\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt128\n\n\nPCG_RXS_M_XS\n\n\nUInt128\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt64\n\n\nPCG_XSL_RR\n\n\nUInt32\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt128\n\n\nPCG_XSL_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt64\n\n\nPCG_XSL_RR\n\n\nUInt32\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt128\n\n\nPCG_XSL_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt64\n\n\nPCG_XSL_RR\n\n\nUInt32\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt128\n\n\nPCG_XSL_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt64\n\n\nPCG_XSL_RR\n\n\nUInt32\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt128\n\n\nPCG_XSL_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt64\n\n\nPCG_XSL_RR_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt128\n\n\nPCG_XSL_RR_RR\n\n\nUInt128\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt64\n\n\nPCG_XSL_RR_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt128\n\n\nPCG_XSL_RR_RR\n\n\nUInt128\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt64\n\n\nPCG_XSL_RR_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt128\n\n\nPCG_XSL_RR_RR\n\n\nUInt128\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nRNG.PCG.PCGStateMCG\n \n \nType\n.\n\n\nPCGStateMCG\n{\nStateType\n:\nPCGUInt\n,\n \nMethodType\n:\nPCGMethod\n,\n \nOutputType\n:\nPCGUInt\n}\n \n:\n\n    \nAbstractPCG\n{\nStateType\n,\n \nMethodType\n,\n \nOutputType\n}\n\n\nPCGStateMCG\n([\nseed\n])\n\n\nPCGStateMCG\n(\noutput_type\n[,\n \nseed\n])\n\n\nPCGStateMCG\n(\nmethod\n[,\n \nseed\n])\n\n\nPCGStateMCG\n(\noutput_type\n[,\n \nmethod\n,\n \nseed\n])\n\n\n\n\n\n\nPCG generator with \nMCG\n, where the increment is zero, resulting in a single stream and reduced period.\n\n\nseed\n is an \nInteger\n which will be automatically converted to the state type.\n\n\noutput_type\n is the type of the PCG's output. If missing it is set to \nUInt64\n.\n\n\nmethod\n is one of the \nPCGMethod\n. If missing it is set to \nPCG_XSH_RS\n.\n\n\nSee \nPCG_LIST\n for the available parameter combinations.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.PCGStateOneseq\n \n \nType\n.\n\n\nPCGStateOneseq\n{\nStateType\n:\nPCGUInt\n,\n \nMethodType\n:\nPCGMethod\n,\n \nOutputType\n:\nPCGUInt\n}\n \n:\n\n    \nAbstractPCG\n{\nStateType\n,\n \nMethodType\n,\n \nOutputType\n}\n\n\nPCGStateOneseq\n([\nseed\n])\n\n\nPCGStateOneseq\n(\noutput_type\n[,\n \nseed\n])\n\n\nPCGStateOneseq\n(\nmethod\n[,\n \nseed\n])\n\n\nPCGStateOneseq\n(\noutput_type\n[,\n \nmethod\n,\n \nseed\n])\n\n\n\n\n\n\nPCG generator with \nsingle streams\n, where all instances use the same fixed constant, thus the RNG always somewhere in same sequence.\n\n\nseed\n is an \nInteger\n which will be automatically converted to the state type.\n\n\noutput_type\n is the type of the PCG's output. If missing it is set to \nUInt64\n.\n\n\nmethod\n is one of the \nPCGMethod\n. If missing it is set to \nPCG_XSH_RS\n.\n\n\nSee \nPCG_LIST\n for the available parameter combinations.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.PCGStateSetseq\n \n \nType\n.\n\n\nPCGStateSetseq\n{\nStateType\n:\nPCGUInt\n,\n \nMethodType\n:\nPCGMethod\n,\n \nOutputType\n:\nPCGUInt\n}\n \n:\n\n    \nAbstractPCG\n{\nStateType\n,\n \nMethodType\n,\n \nOutputType\n}\n\n\nPCGStateSetseq\n([\nseed\n])\n\n\nPCGStateSetseq\n(\noutput_type\n[,\n \nseed\n])\n\n\nPCGStateSetseq\n(\nmethod\n[,\n \nseed\n])\n\n\nPCGStateSetseq\n(\noutput_type\n[,\n \nmethod\n,\n \nseed\n])\n\n\n\n\n\n\nPCG generator with \nspecific streams\n, where the constant can be changed at any time, selecting a different random sequence.\n\n\nseed\n is a \nTuple\n of two \nInteger\ns which will both be automatically converted to the state type.\n\n\noutput_type\n is the type of the PCG's output. If missing it is set to \nUInt64\n.\n\n\nmethod\n is one of the \nPCGMethod\n. If missing it is set to \nPCG_XSH_RS\n.\n\n\nSee \nPCG_LIST\n for the available parameter combinations.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.PCGStateUnique\n \n \nType\n.\n\n\nPCGStateUnique\n{\nStateType\n:\nPCGUInt\n,\n \nMethodType\n:\nPCGMethod\n,\n \nOutputType\n:\nPCGUInt\n}\n \n:\n\n    \nAbstractPCG\n{\nStateType\n,\n \nMethodType\n,\n \nOutputType\n}\n\n\nPCGStateUnique\n([\nseed\n])\n\n\nPCGStateUnique\n(\noutput_type\n[,\n \nseed\n])\n\n\nPCGStateUnique\n(\nmethod\n[,\n \nseed\n])\n\n\nPCGStateUnique\n(\noutput_type\n[,\n \nmethod\n,\n \nseed\n])\n\n\n\n\n\n\nPCG generator with \nunique streams\n, where the constant is based on the memory address of the object, thus every RNG has its own unique sequence.\n\n\nseed\n is an \nInteger\n which will be automatically converted to the state type.\n\n\noutput_type\n is the type of the PCG's output. If missing it is set to \nUInt64\n.\n\n\nmethod\n is one of the \nPCGMethod\n. If missing it is set to \nPCG_XSH_RS\n.\n\n\nSee \nPCG_LIST\n for the available parameter combinations.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.advance!\n \n \nMethod\n.\n\n\nadvance!\n(\nr\n,\n \n\u0394\n)\n\n\n\n\n\n\nAdvance a PCG object \nr\n for \n\u0394\n steps.\n\n\nExamples\n\n\njulia\n \nr\n \n=\n \nPCGStateSetseq\n(\nUInt64\n,\n \nPCG_RXS_M_XS\n,\n \n(\n123\n,\n \n321\n))\n\n\nRNG.PCG.PCGStateSetseq{UInt64,Val{:RXS_M_XS},UInt64}(0x45389f8b27528b29,0x0000000000000283)\n\n\n\njulia\n \nA\n \n=\n \nrand\n(\nr\n,\n \nUInt64\n,\n \n2\n);\n\n\n\njulia\n \np\n \n=\n \nrand\n(\nr\n);\n\n\n\njulia\n \nr\n\n\nRNG.PCG.PCGStateSetseq{UInt64,Val{:RXS_M_XS},UInt64}(0x9b1fc763ae0ad702,0x0000000000000283)\n\n\n\njulia\n \nadvance!\n(\nr\n,\n \n-\n3\n)\n\n\nRNG.PCG.PCGStateSetseq{UInt64,Val{:RXS_M_XS},UInt64}(0x45389f8b27528b29,0x0000000000000283)\n\n\n\njulia\n \n@\nTest\n.\ntest\n \nA\n \n==\n \nrand\n(\nr\n,\n \nUInt64\n,\n \n2\n)\n\n\nTest Passed\n\n\n  Expression: A == rand(r,UInt64,2)\n\n\n   Evaluated: UInt64[0x245806d421c0d835,0x5b6bc4b066eda37f] == UInt64[0x245806d421c0d835,0x5b6bc4b066eda37f]\n\n\n\njulia\n \n@\nTest\n.\ntest\n \np\n \n==\n \nrand\n(\nr\n)\n\n\nTest Passed\n\n\n  Expression: p == rand(r)\n\n\n   Evaluated: 0.3950038072091506 == 0.3950038072091506\n\n\n\n\n\n\nsource\n\n\n#\n\n\nRNG.PCG.bounded_rand\n \n \nMethod\n.\n\n\nbounded_rand\n(\nr\n,\n \nbound\n)\n\n\n\n\n\n\nProducing a random number less than a given \nbound\n in the output type.\n\n\nsource\n\n\n\n\nInternal\n\n\n#\n\n\nRNG.PCG.AbstractPCG\n \n \nType\n.\n\n\nAbstractPCG\n{\nStateType\n:\nPCGUInt\n,\n \nMethodType\n:\nPCGMethod\n,\n \nOutputType\n:\nPCGUInt\n}\n \n:\n \nAbstractRNG\n{\nOutputType\n}\n\n\n\n\n\n\nThe base abstract type for PCGs.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.default_increment\n \n \nMethod\n.\n\n\nReturn the default increment for a certain type.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.default_multiplier\n \n \nMethod\n.\n\n\nReturn the default multiplier for a certain type.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.mcg_multiplier\n \n \nMethod\n.\n\n\nReturn the default MCG multiplier for a certain type.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.mcg_unmultiplier\n \n \nMethod\n.\n\n\nReturn the default MCG unmultiplier for a certain type.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.pcg_advance!\n \n \nFunction\n.\n\n\nAdvance a PCG object.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.pcg_advance_lcg\n \n \nMethod\n.\n\n\nGeneral advance functions.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.pcg_output\n \n \nFunction\n.\n\n\nReturn the output of a state for a certain PCG type.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.pcg_srand\n \n \nFunction\n.\n\n\nInitialize a PCG object.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.pcg_step!\n \n \nFunction\n.\n\n\nDo one iteration step for a PCG object.\n\n\nsource", 
            "title": "PCG"
        }, 
        {
            "location": "/lib/pcg/#pcg", 
            "text": "", 
            "title": "PCG"
        }, 
        {
            "location": "/lib/pcg/#index", 
            "text": "RNG.PCG  RNG.PCG.PCGMethod  RNG.PCG.PCG_LIST  RNG.PCG.AbstractPCG  RNG.PCG.PCGStateMCG  RNG.PCG.PCGStateOneseq  RNG.PCG.PCGStateSetseq  RNG.PCG.PCGStateUnique  RNG.PCG.advance!  RNG.PCG.bounded_rand  RNG.PCG.default_increment  RNG.PCG.default_multiplier  RNG.PCG.mcg_multiplier  RNG.PCG.mcg_unmultiplier  RNG.PCG.pcg_advance!  RNG.PCG.pcg_advance_lcg  RNG.PCG.pcg_output  RNG.PCG.pcg_srand  RNG.PCG.pcg_step!", 
            "title": "Index"
        }, 
        {
            "location": "/lib/pcg/#public", 
            "text": "#  RNG.PCG     Module .  The module for  Random123 Family .  source  #  RNG.PCG.PCGMethod     Constant .  The  Union  of all the PCG method types:  PCG_XSH_RS ,  PCG_XSH_RR ,  PCG_RXS_M_XS ,  PCG_XSL_RR , and  PCG_XSL_RR_RR .  source  #  RNG.PCG.PCG_LIST     Constant .  The list of all the parameter combinations that can be used for PCG.     Stream variation  State Type  Method Type  Output Type      PCGStateOneseq  UInt16  PCG_XSH_RS  UInt8    PCGStateOneseq  UInt32  PCG_XSH_RS  UInt16    PCGStateOneseq  UInt64  PCG_XSH_RS  UInt32    PCGStateOneseq  UInt128  PCG_XSH_RS  UInt64    PCGStateUnique  UInt16  PCG_XSH_RS  UInt8    PCGStateUnique  UInt32  PCG_XSH_RS  UInt16    PCGStateUnique  UInt64  PCG_XSH_RS  UInt32    PCGStateUnique  UInt128  PCG_XSH_RS  UInt64    PCGStateSetseq  UInt16  PCG_XSH_RS  UInt8    PCGStateSetseq  UInt32  PCG_XSH_RS  UInt16    PCGStateSetseq  UInt64  PCG_XSH_RS  UInt32    PCGStateSetseq  UInt128  PCG_XSH_RS  UInt64    PCGStateMCG  UInt16  PCG_XSH_RS  UInt8    PCGStateMCG  UInt32  PCG_XSH_RS  UInt16    PCGStateMCG  UInt64  PCG_XSH_RS  UInt32    PCGStateMCG  UInt128  PCG_XSH_RS  UInt64    PCGStateOneseq  UInt16  PCG_XSH_RR  UInt8    PCGStateOneseq  UInt32  PCG_XSH_RR  UInt16    PCGStateOneseq  UInt64  PCG_XSH_RR  UInt32    PCGStateOneseq  UInt128  PCG_XSH_RR  UInt64    PCGStateUnique  UInt16  PCG_XSH_RR  UInt8    PCGStateUnique  UInt32  PCG_XSH_RR  UInt16    PCGStateUnique  UInt64  PCG_XSH_RR  UInt32    PCGStateUnique  UInt128  PCG_XSH_RR  UInt64    PCGStateSetseq  UInt16  PCG_XSH_RR  UInt8    PCGStateSetseq  UInt32  PCG_XSH_RR  UInt16    PCGStateSetseq  UInt64  PCG_XSH_RR  UInt32    PCGStateSetseq  UInt128  PCG_XSH_RR  UInt64    PCGStateMCG  UInt16  PCG_XSH_RR  UInt8    PCGStateMCG  UInt32  PCG_XSH_RR  UInt16    PCGStateMCG  UInt64  PCG_XSH_RR  UInt32    PCGStateMCG  UInt128  PCG_XSH_RR  UInt64    PCGStateOneseq  UInt8  PCG_RXS_M_XS  UInt8    PCGStateOneseq  UInt16  PCG_RXS_M_XS  UInt16    PCGStateOneseq  UInt32  PCG_RXS_M_XS  UInt32    PCGStateOneseq  UInt64  PCG_RXS_M_XS  UInt64    PCGStateOneseq  UInt128  PCG_RXS_M_XS  UInt128    PCGStateUnique  UInt16  PCG_RXS_M_XS  UInt16    PCGStateUnique  UInt32  PCG_RXS_M_XS  UInt32    PCGStateUnique  UInt64  PCG_RXS_M_XS  UInt64    PCGStateUnique  UInt128  PCG_RXS_M_XS  UInt128    PCGStateSetseq  UInt8  PCG_RXS_M_XS  UInt8    PCGStateSetseq  UInt16  PCG_RXS_M_XS  UInt16    PCGStateSetseq  UInt32  PCG_RXS_M_XS  UInt32    PCGStateSetseq  UInt64  PCG_RXS_M_XS  UInt64    PCGStateSetseq  UInt128  PCG_RXS_M_XS  UInt128    PCGStateOneseq  UInt64  PCG_XSL_RR  UInt32    PCGStateOneseq  UInt128  PCG_XSL_RR  UInt64    PCGStateUnique  UInt64  PCG_XSL_RR  UInt32    PCGStateUnique  UInt128  PCG_XSL_RR  UInt64    PCGStateSetseq  UInt64  PCG_XSL_RR  UInt32    PCGStateSetseq  UInt128  PCG_XSL_RR  UInt64    PCGStateMCG  UInt64  PCG_XSL_RR  UInt32    PCGStateMCG  UInt128  PCG_XSL_RR  UInt64    PCGStateOneseq  UInt64  PCG_XSL_RR_RR  UInt64    PCGStateOneseq  UInt128  PCG_XSL_RR_RR  UInt128    PCGStateUnique  UInt64  PCG_XSL_RR_RR  UInt64    PCGStateUnique  UInt128  PCG_XSL_RR_RR  UInt128    PCGStateSetseq  UInt64  PCG_XSL_RR_RR  UInt64    PCGStateSetseq  UInt128  PCG_XSL_RR_RR  UInt128     source  #  RNG.PCG.PCGStateMCG     Type .  PCGStateMCG { StateType : PCGUInt ,   MethodType : PCGMethod ,   OutputType : PCGUInt }   : \n     AbstractPCG { StateType ,   MethodType ,   OutputType }  PCGStateMCG ([ seed ])  PCGStateMCG ( output_type [,   seed ])  PCGStateMCG ( method [,   seed ])  PCGStateMCG ( output_type [,   method ,   seed ])   PCG generator with  MCG , where the increment is zero, resulting in a single stream and reduced period.  seed  is an  Integer  which will be automatically converted to the state type.  output_type  is the type of the PCG's output. If missing it is set to  UInt64 .  method  is one of the  PCGMethod . If missing it is set to  PCG_XSH_RS .  See  PCG_LIST  for the available parameter combinations.  source  #  RNG.PCG.PCGStateOneseq     Type .  PCGStateOneseq { StateType : PCGUInt ,   MethodType : PCGMethod ,   OutputType : PCGUInt }   : \n     AbstractPCG { StateType ,   MethodType ,   OutputType }  PCGStateOneseq ([ seed ])  PCGStateOneseq ( output_type [,   seed ])  PCGStateOneseq ( method [,   seed ])  PCGStateOneseq ( output_type [,   method ,   seed ])   PCG generator with  single streams , where all instances use the same fixed constant, thus the RNG always somewhere in same sequence.  seed  is an  Integer  which will be automatically converted to the state type.  output_type  is the type of the PCG's output. If missing it is set to  UInt64 .  method  is one of the  PCGMethod . If missing it is set to  PCG_XSH_RS .  See  PCG_LIST  for the available parameter combinations.  source  #  RNG.PCG.PCGStateSetseq     Type .  PCGStateSetseq { StateType : PCGUInt ,   MethodType : PCGMethod ,   OutputType : PCGUInt }   : \n     AbstractPCG { StateType ,   MethodType ,   OutputType }  PCGStateSetseq ([ seed ])  PCGStateSetseq ( output_type [,   seed ])  PCGStateSetseq ( method [,   seed ])  PCGStateSetseq ( output_type [,   method ,   seed ])   PCG generator with  specific streams , where the constant can be changed at any time, selecting a different random sequence.  seed  is a  Tuple  of two  Integer s which will both be automatically converted to the state type.  output_type  is the type of the PCG's output. If missing it is set to  UInt64 .  method  is one of the  PCGMethod . If missing it is set to  PCG_XSH_RS .  See  PCG_LIST  for the available parameter combinations.  source  #  RNG.PCG.PCGStateUnique     Type .  PCGStateUnique { StateType : PCGUInt ,   MethodType : PCGMethod ,   OutputType : PCGUInt }   : \n     AbstractPCG { StateType ,   MethodType ,   OutputType }  PCGStateUnique ([ seed ])  PCGStateUnique ( output_type [,   seed ])  PCGStateUnique ( method [,   seed ])  PCGStateUnique ( output_type [,   method ,   seed ])   PCG generator with  unique streams , where the constant is based on the memory address of the object, thus every RNG has its own unique sequence.  seed  is an  Integer  which will be automatically converted to the state type.  output_type  is the type of the PCG's output. If missing it is set to  UInt64 .  method  is one of the  PCGMethod . If missing it is set to  PCG_XSH_RS .  See  PCG_LIST  for the available parameter combinations.  source  #  RNG.PCG.advance!     Method .  advance! ( r ,   \u0394 )   Advance a PCG object  r  for  \u0394  steps.  Examples  julia   r   =   PCGStateSetseq ( UInt64 ,   PCG_RXS_M_XS ,   ( 123 ,   321 ))  RNG.PCG.PCGStateSetseq{UInt64,Val{:RXS_M_XS},UInt64}(0x45389f8b27528b29,0x0000000000000283)  julia   A   =   rand ( r ,   UInt64 ,   2 );  julia   p   =   rand ( r );  julia   r  RNG.PCG.PCGStateSetseq{UInt64,Val{:RXS_M_XS},UInt64}(0x9b1fc763ae0ad702,0x0000000000000283)  julia   advance! ( r ,   - 3 )  RNG.PCG.PCGStateSetseq{UInt64,Val{:RXS_M_XS},UInt64}(0x45389f8b27528b29,0x0000000000000283)  julia   @ Test . test   A   ==   rand ( r ,   UInt64 ,   2 )  Test Passed    Expression: A == rand(r,UInt64,2)     Evaluated: UInt64[0x245806d421c0d835,0x5b6bc4b066eda37f] == UInt64[0x245806d421c0d835,0x5b6bc4b066eda37f]  julia   @ Test . test   p   ==   rand ( r )  Test Passed    Expression: p == rand(r)     Evaluated: 0.3950038072091506 == 0.3950038072091506   source  #  RNG.PCG.bounded_rand     Method .  bounded_rand ( r ,   bound )   Producing a random number less than a given  bound  in the output type.  source", 
            "title": "Public"
        }, 
        {
            "location": "/lib/pcg/#internal", 
            "text": "#  RNG.PCG.AbstractPCG     Type .  AbstractPCG { StateType : PCGUInt ,   MethodType : PCGMethod ,   OutputType : PCGUInt }   :   AbstractRNG { OutputType }   The base abstract type for PCGs.  source  #  RNG.PCG.default_increment     Method .  Return the default increment for a certain type.  source  #  RNG.PCG.default_multiplier     Method .  Return the default multiplier for a certain type.  source  #  RNG.PCG.mcg_multiplier     Method .  Return the default MCG multiplier for a certain type.  source  #  RNG.PCG.mcg_unmultiplier     Method .  Return the default MCG unmultiplier for a certain type.  source  #  RNG.PCG.pcg_advance!     Function .  Advance a PCG object.  source  #  RNG.PCG.pcg_advance_lcg     Method .  General advance functions.  source  #  RNG.PCG.pcg_output     Function .  Return the output of a state for a certain PCG type.  source  #  RNG.PCG.pcg_srand     Function .  Initialize a PCG object.  source  #  RNG.PCG.pcg_step!     Function .  Do one iteration step for a PCG object.  source", 
            "title": "Internal"
        }, 
        {
            "location": "/lib/mersenne-twisters/", 
            "text": "MersenneTwisters\n\n\n\n\nIndex\n\n\n\n\nRNG.MersenneTwisters\n\n\nRNG.MersenneTwisters.MT19937\n\n\nRNG.MersenneTwisters.MersenneTwister\n\n\nRNG.MersenneTwisters.mt_get\n\n\nRNG.MersenneTwisters.mt_set!\n\n\nRNG.MersenneTwisters.mt_set!\n\n\n\n\n\n\nPublic\n\n\n#\n\n\nRNG.MersenneTwisters\n \n \nModule\n.\n\n\nThe module for \nMersenne Twisters\n.\n\n\nCurrently only provide one RNG type:\n\n\n\n\nMT19937\n\n\n\n\nsource\n\n\n#\n\n\nRNG.MersenneTwisters.MT19937\n \n \nType\n.\n\n\nMT19937\n \n:\n \nMersenneTwister\n{\nUInt32\n}\n\n\nMT19937\n([\nseed\n])\n\n\n\n\n\n\nMT19937 RNG. The \nseed\n is a \nTuple\n of 624 \nUInt32\n numbers, or an \nInteger\n which will be automatically convert to an \nUInt32\n number.\n\n\nsource\n\n\n\n\nInternal\n\n\n#\n\n\nRNG.MersenneTwisters.MersenneTwister\n \n \nType\n.\n\n\nMersenneTwister\n{\nT\n}\n \n:\n \nRNG\n.\nAbstractRNG\n{\nT\n}\n\n\n\n\n\n\nThe base type of Mersenne Twisters.\n\n\nsource\n\n\n#\n\n\nRNG.MersenneTwisters.mt_get\n \n \nMethod\n.\n\n\nGet a random \nUInt32\n number from a \nMT19937\n object.\n\n\nsource\n\n\n#\n\n\nRNG.MersenneTwisters.mt_set!\n \n \nMethod\n.\n\n\nSet up a \nMT19937\n RNG object using a \nTuple\n of 624 \nUInt32\n numbers.\n\n\nsource\n\n\n#\n\n\nRNG.MersenneTwisters.mt_set!\n \n \nMethod\n.\n\n\nSet up a \nMT19937\n RNG object using an \nUInt32\n number.\n\n\nsource", 
            "title": "MersenneTwisters"
        }, 
        {
            "location": "/lib/mersenne-twisters/#mersennetwisters", 
            "text": "", 
            "title": "MersenneTwisters"
        }, 
        {
            "location": "/lib/mersenne-twisters/#index", 
            "text": "RNG.MersenneTwisters  RNG.MersenneTwisters.MT19937  RNG.MersenneTwisters.MersenneTwister  RNG.MersenneTwisters.mt_get  RNG.MersenneTwisters.mt_set!  RNG.MersenneTwisters.mt_set!", 
            "title": "Index"
        }, 
        {
            "location": "/lib/mersenne-twisters/#public", 
            "text": "#  RNG.MersenneTwisters     Module .  The module for  Mersenne Twisters .  Currently only provide one RNG type:   MT19937   source  #  RNG.MersenneTwisters.MT19937     Type .  MT19937   :   MersenneTwister { UInt32 }  MT19937 ([ seed ])   MT19937 RNG. The  seed  is a  Tuple  of 624  UInt32  numbers, or an  Integer  which will be automatically convert to an  UInt32  number.  source", 
            "title": "Public"
        }, 
        {
            "location": "/lib/mersenne-twisters/#internal", 
            "text": "#  RNG.MersenneTwisters.MersenneTwister     Type .  MersenneTwister { T }   :   RNG . AbstractRNG { T }   The base type of Mersenne Twisters.  source  #  RNG.MersenneTwisters.mt_get     Method .  Get a random  UInt32  number from a  MT19937  object.  source  #  RNG.MersenneTwisters.mt_set!     Method .  Set up a  MT19937  RNG object using a  Tuple  of 624  UInt32  numbers.  source  #  RNG.MersenneTwisters.mt_set!     Method .  Set up a  MT19937  RNG object using an  UInt32  number.  source", 
            "title": "Internal"
        }, 
        {
            "location": "/lib/random123/", 
            "text": "Random123\n\n\n\n\nIndex\n\n\n\n\nRNG.Random123\n\n\nRNG.Random123.R123_USE_AESNI\n\n\nRNG.Random123.AbstractR123\n\n\nRNG.Random123.Philox2x\n\n\nRNG.Random123.Philox4x\n\n\nRNG.Random123.R123Generator1x\n\n\nRNG.Random123.R123Generator2x\n\n\nRNG.Random123.R123Generator4x\n\n\nRNG.Random123.Threefry2x\n\n\nRNG.Random123.Threefry4x\n\n\nRNG.Random123.random123_r\n\n\n\n\n\n\nPublic\n\n\n#\n\n\nRNG.Random123\n \n \nModule\n.\n\n\nThe module for \nRandom123 Family\n.\n\n\nProvide 8 RNG types:\n\n\n\n\nThreefry2x\n\n\nThreefry4x\n\n\nPhilox2x\n\n\nPhilox4x\n\n\nAESNI1x\n\n\nAESNI4x\n\n\nARS1x\n\n\nARS4x\n\n\n\n\nsource\n\n\n#\n\n\nRNG.Random123.R123_USE_AESNI\n \n \nConstant\n.\n\n\nTrue when AES-NI library has been compiled.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.Philox2x\n \n \nType\n.\n\n\nPhilox2x\n{\nT\n,\n \nR\n}\n \n:\n \nR123Generator2x\n{\nT\n}\n\n\nPhilox2x\n([\nseed\n,\n \nR\n])\n\n\nPhilox2x\n(\nT\n[,\n \nseed\n,\n \nR\n])\n\n\n\n\n\n\nPhilox2x is one kind of Philox Counter-Based RNGs. It generates two numbers at a time.\n\n\nT\n is \nUInt32\n or \nUInt64\n(default).\n\n\nseed\n is an \nInteger\n which will be automatically converted to \nT\n.\n\n\nR\n denotes to the Rounds. With 10 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.Philox4x\n \n \nType\n.\n\n\nPhilox4x\n{\nT\n,\n \nR\n}\n \n:\n \nR123Generator4x\n{\nT\n}\n\n\nPhilox4x\n([\nseed\n,\n \nR\n])\n\n\nPhilox4x\n(\nT\n[,\n \nseed\n,\n \nR\n])\n\n\n\n\n\n\nPhilox4x is one kind of Philox Counter-Based RNGs. It generates four numbers at a time.\n\n\nT\n is \nUInt32\n or \nUInt64\n(default).\n\n\nseed\n is a \nTuple\n of two \nInteger\ns which will both be automatically converted to \nT\n.\n\n\nR\n denotes to the Rounds. With 10 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.Threefry2x\n \n \nType\n.\n\n\nThreefry2x\n{\nT\n,\n \nR\n}\n \n:\n \nR123Generator2x\n{\nT\n}\n\n\nThreefry2x\n([\nseed\n,\n \nR\n])\n\n\nThreefry2x\n(\nT\n[,\n \nseed\n,\n \nR\n])\n\n\n\n\n\n\nThreefry2x is one kind of Threefry Counter-Based RNGs. It generates two numbers at a time.\n\n\nT\n is \nUInt32\n or \nUInt64\n(default).\n\n\nseed\n is a \nTuple\n of two \nInteger\ns which will both be automatically converted to \nT\n.\n\n\nR\n denotes to the Rounds. With 20 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.Threefry4x\n \n \nType\n.\n\n\nThreefry4x\n{\nT\n,\n \nR\n}\n \n:\n \nR123Generator4x\n{\nT\n}\n\n\nThreefry4x\n([\nseed\n,\n \nR\n])\n\n\nThreefry4x\n(\nT\n[,\n \nseed\n,\n \nR\n])\n\n\n\n\n\n\nThreefry2x is one kind of Threefry Counter-Based RNGs. It generates four numbers at a time.\n\n\nT\n is \nUInt32\n or \nUInt64\n(default).\n\n\nseed\n is a \nTuple\n of four \nInteger\ns which will all be automatically converted to \nT\n.\n\n\nR\n denotes to the Rounds. With 20 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.\n\n\nsource\n\n\n\n\nInternal\n\n\n#\n\n\nRNG.Random123.AbstractR123\n \n \nType\n.\n\n\nThe base abstract type for RNGs in \nRandom123 Family\n.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.R123Generator1x\n \n \nType\n.\n\n\nRNG that generates one number at a time.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.R123Generator2x\n \n \nType\n.\n\n\nRNG that generates two numbers at a time.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.R123Generator4x\n \n \nType\n.\n\n\nRNG that generates four numbers at a time.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.random123_r\n \n \nFunction\n.\n\n\nDo one iteration and return the a tuple of a Random123 RNG object.\n\n\nsource", 
            "title": "Random123"
        }, 
        {
            "location": "/lib/random123/#random123", 
            "text": "", 
            "title": "Random123"
        }, 
        {
            "location": "/lib/random123/#index", 
            "text": "RNG.Random123  RNG.Random123.R123_USE_AESNI  RNG.Random123.AbstractR123  RNG.Random123.Philox2x  RNG.Random123.Philox4x  RNG.Random123.R123Generator1x  RNG.Random123.R123Generator2x  RNG.Random123.R123Generator4x  RNG.Random123.Threefry2x  RNG.Random123.Threefry4x  RNG.Random123.random123_r", 
            "title": "Index"
        }, 
        {
            "location": "/lib/random123/#public", 
            "text": "#  RNG.Random123     Module .  The module for  Random123 Family .  Provide 8 RNG types:   Threefry2x  Threefry4x  Philox2x  Philox4x  AESNI1x  AESNI4x  ARS1x  ARS4x   source  #  RNG.Random123.R123_USE_AESNI     Constant .  True when AES-NI library has been compiled.  source  #  RNG.Random123.Philox2x     Type .  Philox2x { T ,   R }   :   R123Generator2x { T }  Philox2x ([ seed ,   R ])  Philox2x ( T [,   seed ,   R ])   Philox2x is one kind of Philox Counter-Based RNGs. It generates two numbers at a time.  T  is  UInt32  or  UInt64 (default).  seed  is an  Integer  which will be automatically converted to  T .  R  denotes to the Rounds. With 10 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.  source  #  RNG.Random123.Philox4x     Type .  Philox4x { T ,   R }   :   R123Generator4x { T }  Philox4x ([ seed ,   R ])  Philox4x ( T [,   seed ,   R ])   Philox4x is one kind of Philox Counter-Based RNGs. It generates four numbers at a time.  T  is  UInt32  or  UInt64 (default).  seed  is a  Tuple  of two  Integer s which will both be automatically converted to  T .  R  denotes to the Rounds. With 10 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.  source  #  RNG.Random123.Threefry2x     Type .  Threefry2x { T ,   R }   :   R123Generator2x { T }  Threefry2x ([ seed ,   R ])  Threefry2x ( T [,   seed ,   R ])   Threefry2x is one kind of Threefry Counter-Based RNGs. It generates two numbers at a time.  T  is  UInt32  or  UInt64 (default).  seed  is a  Tuple  of two  Integer s which will both be automatically converted to  T .  R  denotes to the Rounds. With 20 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.  source  #  RNG.Random123.Threefry4x     Type .  Threefry4x { T ,   R }   :   R123Generator4x { T }  Threefry4x ([ seed ,   R ])  Threefry4x ( T [,   seed ,   R ])   Threefry2x is one kind of Threefry Counter-Based RNGs. It generates four numbers at a time.  T  is  UInt32  or  UInt64 (default).  seed  is a  Tuple  of four  Integer s which will all be automatically converted to  T .  R  denotes to the Rounds. With 20 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.  source", 
            "title": "Public"
        }, 
        {
            "location": "/lib/random123/#internal", 
            "text": "#  RNG.Random123.AbstractR123     Type .  The base abstract type for RNGs in  Random123 Family .  source  #  RNG.Random123.R123Generator1x     Type .  RNG that generates one number at a time.  source  #  RNG.Random123.R123Generator2x     Type .  RNG that generates two numbers at a time.  source  #  RNG.Random123.R123Generator4x     Type .  RNG that generates four numbers at a time.  source  #  RNG.Random123.random123_r     Function .  Do one iteration and return the a tuple of a Random123 RNG object.  source", 
            "title": "Internal"
        }, 
        {
            "location": "/lib/xorshifts/", 
            "text": "Xorshifts\n\n\n\n\nIndex\n\n\n\n\nRNG.Xorshifts\n\n\nRNG.Xorshifts.AbstractXoroshiro128\n\n\nRNG.Xorshifts.AbstractXorshift1024\n\n\nRNG.Xorshifts.AbstractXorshift128\n\n\nRNG.Xorshifts.AbstractXorshift64\n\n\nRNG.Xorshifts.Xoroshiro128\n\n\nRNG.Xorshifts.Xoroshiro128Plus\n\n\nRNG.Xorshifts.Xoroshiro128Star\n\n\nRNG.Xorshifts.Xorshift1024\n\n\nRNG.Xorshifts.Xorshift1024Plus\n\n\nRNG.Xorshifts.Xorshift1024Star\n\n\nRNG.Xorshifts.Xorshift128\n\n\nRNG.Xorshifts.Xorshift128Plus\n\n\nRNG.Xorshifts.Xorshift128Star\n\n\nRNG.Xorshifts.Xorshift64\n\n\nRNG.Xorshifts.Xorshift64Star\n\n\nRNG.Xorshifts.xorshift_next\n\n\n\n\n\n\nPublic\n\n\n#\n\n\nRNG.Xorshifts\n \n \nModule\n.\n\n\nThe module for \nXorshift Family\n.\n\n\nProvide 11 RNG types:\n\n\n\n\nXorshift64\n\n\nXorshift64Star\n\n\nXorshift128\n\n\nXorshift128Star\n\n\nXorshift128Plus\n\n\nXorshift1024\n\n\nXorshift1024Star\n\n\nXorshift1024Plus\n\n\nXoroshiro128\n\n\nXoroshiro128Star\n\n\nXoroshiro128Plus\n\n\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xoroshiro128\n \n \nType\n.\n\n\nXoroshiro128\n{\nT\n}\n \n:\n \nAbstractXoroshiro128\n{\nT\n}\n\n\nXoroshiro128\n([\nseed\n])\n\n\n\n\n\n\nXoroshiro128 RNG. The \nseed\n can be a \nTuple\n of two \nUInt64\ns, or an \nInteger\n which will be automatically convert to an \nUInt128\n number.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xoroshiro128Plus\n \n \nType\n.\n\n\nXoroshiro128Plus\n{\nT\n}\n \n:\n \nAbstractXoroshiro128\n{\nT\n}\n\n\nXoroshiro128Plus\n([\nseed\n])\n\n\n\n\n\n\nXoroshiro128Plus RNG. The \nseed\n can be a \nTuple\n of two \nUInt64\ns, or an \nInteger\n which will be automatically convert to an \nUInt128\n number.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xoroshiro128Star\n \n \nType\n.\n\n\nXoroshiro128Star\n{\nT\n}\n \n:\n \nAbstractXoroshiro128\n{\nT\n}\n\n\nXoroshiro128Star\n([\nseed\n])\n\n\n\n\n\n\nXoroshiro128Star RNG. The \nseed\n can be a \nTuple\n of two \nUInt64\ns, or an \nInteger\n which will be automatically convert to an \nUInt128\n number.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xorshift1024\n \n \nType\n.\n\n\nXorshift1024\n{\nT\n}\n \n:\n \nAbstractXorshift1024\n{\nT\n}\n\n\nXorshift1024\n([\nseed\n...\n])\n\n\n\n\n\n\nXorshift1024 RNG. The \nseed\n can be a \nTuple\n of 16 \nUInt64\ns, or several (no more than 16) \nInteger\ns which will all be automatically converted to \nUInt64\n numbers.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xorshift1024Plus\n \n \nType\n.\n\n\nXorshift1024Plus\n{\nT\n}\n \n:\n \nAbstractXorshift1024\n{\nT\n}\n\n\nXorshift1024Plus\n([\nseed\n...\n])\n\n\n\n\n\n\nXorshift1024Plus RNG. The \nseed\n can be a \nTuple\n of 16 \nUInt64\ns, or several (no more than 16) \nInteger\ns which will all be automatically converted to \nUInt64\n numbers.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xorshift1024Star\n \n \nType\n.\n\n\nXorshift1024Star\n{\nT\n}\n \n:\n \nAbstractXorshift1024\n{\nT\n}\n\n\nXorshift1024Star\n([\nseed\n...\n])\n\n\n\n\n\n\nXorshift1024Star RNG. The \nseed\n can be a \nTuple\n of 16 \nUInt64\ns, or several (no more than 16) \nInteger\ns which will all be automatically converted to \nUInt64\n numbers.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xorshift128\n \n \nType\n.\n\n\nXorshift128\n{\nT\n}\n \n:\n \nAbstractXorshift128\n{\nT\n}\n\n\nXorshift128\n([\nseed\n])\n\n\n\n\n\n\nXorshift128 RNG. The \nseed\n can be a \nTuple\n of two \nUInt64\ns, or an \nInteger\n which will be automatically convert to an \nUInt128\n number.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xorshift128Plus\n \n \nType\n.\n\n\nXorshift128Plus\n{\nT\n}\n \n:\n \nAbstractXorshift128\n{\nT\n}\n\n\nXorshift128Plus\n([\nseed\n])\n\n\n\n\n\n\nXorshift128Plus RNG. The \nseed\n can be a \nTuple\n of two \nUInt64\ns, or an \nInteger\n which will be automatically convert to an \nUInt128\n number.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xorshift128Star\n \n \nType\n.\n\n\nXorshift128Star\n{\nT\n}\n \n:\n \nAbstractXorshift128\n{\nT\n}\n\n\nXorshift128Star\n([\nseed\n])\n\n\n\n\n\n\nXorshift128Star RNG. The \nseed\n can be a \nTuple\n of two \nUInt64\ns, or an \nInteger\n which will be automatically convert to an \nUInt128\n number.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xorshift64\n \n \nType\n.\n\n\nXorshift64\n{\nT\n}\n \n:\n \nAbstractXorshift64\n{\nT\n}\n\n\nXorshift64\n([\nseed\n])\n\n\n\n\n\n\nXorshift64 RNG. The \nseed\n will be automatically convert to an \nUInt64\n number.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xorshift64Star\n \n \nType\n.\n\n\nXorshift64Star\n{\nT\n}\n \n:\n \nAbstractXorshift64\n{\nT\n}\n\n\nXorshift64Star\n([\nseed\n])\n\n\n\n\n\n\nXorshift64Star RNG. The \nseed\n will be automatically convert to an \nUInt64\n number.\n\n\nsource\n\n\n\n\nInternal\n\n\n#\n\n\nRNG.Xorshifts.AbstractXoroshiro128\n \n \nType\n.\n\n\nAbstractXoroshiro128\n \n:\n \nAbstractRNG\n{\nUInt64\n}\n\n\n\n\n\n\nThe base abstract type for \nXoroshiro128\n, \nXoroshiro128Star\n and \nXoroshiro128Plus\n.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.AbstractXorshift1024\n \n \nType\n.\n\n\nAbstractXorshift1024\n \n:\n \nAbstractRNG\n{\nUInt64\n}\n\n\n\n\n\n\nThe base abstract type for \nXorshift1024\n, \nXorshift1024Star\n and \nXorshift1024Plus\n.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.AbstractXorshift128\n \n \nType\n.\n\n\nAbstractXorshift128\n \n:\n \nAbstractRNG\n{\nUInt64\n}\n\n\n\n\n\n\nThe base abstract type for \nXorshift128\n, \nXorshift128Star\n and \nXorshift128Plus\n.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.AbstractXorshift64\n \n \nType\n.\n\n\nAbstractXorshift64\n \n:\n \nAbstractRNG\n{\nUInt64\n}\n\n\n\n\n\n\nThe base abstract type for \nXorshift64\n and \nXorshift64Star\n.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.xorshift_next\n \n \nFunction\n.\n\n\nDo one iteration and get the current value of a Xorshift RNG object.\n\n\nsource", 
            "title": "Xorshifts"
        }, 
        {
            "location": "/lib/xorshifts/#xorshifts", 
            "text": "", 
            "title": "Xorshifts"
        }, 
        {
            "location": "/lib/xorshifts/#index", 
            "text": "RNG.Xorshifts  RNG.Xorshifts.AbstractXoroshiro128  RNG.Xorshifts.AbstractXorshift1024  RNG.Xorshifts.AbstractXorshift128  RNG.Xorshifts.AbstractXorshift64  RNG.Xorshifts.Xoroshiro128  RNG.Xorshifts.Xoroshiro128Plus  RNG.Xorshifts.Xoroshiro128Star  RNG.Xorshifts.Xorshift1024  RNG.Xorshifts.Xorshift1024Plus  RNG.Xorshifts.Xorshift1024Star  RNG.Xorshifts.Xorshift128  RNG.Xorshifts.Xorshift128Plus  RNG.Xorshifts.Xorshift128Star  RNG.Xorshifts.Xorshift64  RNG.Xorshifts.Xorshift64Star  RNG.Xorshifts.xorshift_next", 
            "title": "Index"
        }, 
        {
            "location": "/lib/xorshifts/#public", 
            "text": "#  RNG.Xorshifts     Module .  The module for  Xorshift Family .  Provide 11 RNG types:   Xorshift64  Xorshift64Star  Xorshift128  Xorshift128Star  Xorshift128Plus  Xorshift1024  Xorshift1024Star  Xorshift1024Plus  Xoroshiro128  Xoroshiro128Star  Xoroshiro128Plus   source  #  RNG.Xorshifts.Xoroshiro128     Type .  Xoroshiro128 { T }   :   AbstractXoroshiro128 { T }  Xoroshiro128 ([ seed ])   Xoroshiro128 RNG. The  seed  can be a  Tuple  of two  UInt64 s, or an  Integer  which will be automatically convert to an  UInt128  number.  source  #  RNG.Xorshifts.Xoroshiro128Plus     Type .  Xoroshiro128Plus { T }   :   AbstractXoroshiro128 { T }  Xoroshiro128Plus ([ seed ])   Xoroshiro128Plus RNG. The  seed  can be a  Tuple  of two  UInt64 s, or an  Integer  which will be automatically convert to an  UInt128  number.  source  #  RNG.Xorshifts.Xoroshiro128Star     Type .  Xoroshiro128Star { T }   :   AbstractXoroshiro128 { T }  Xoroshiro128Star ([ seed ])   Xoroshiro128Star RNG. The  seed  can be a  Tuple  of two  UInt64 s, or an  Integer  which will be automatically convert to an  UInt128  number.  source  #  RNG.Xorshifts.Xorshift1024     Type .  Xorshift1024 { T }   :   AbstractXorshift1024 { T }  Xorshift1024 ([ seed ... ])   Xorshift1024 RNG. The  seed  can be a  Tuple  of 16  UInt64 s, or several (no more than 16)  Integer s which will all be automatically converted to  UInt64  numbers.  source  #  RNG.Xorshifts.Xorshift1024Plus     Type .  Xorshift1024Plus { T }   :   AbstractXorshift1024 { T }  Xorshift1024Plus ([ seed ... ])   Xorshift1024Plus RNG. The  seed  can be a  Tuple  of 16  UInt64 s, or several (no more than 16)  Integer s which will all be automatically converted to  UInt64  numbers.  source  #  RNG.Xorshifts.Xorshift1024Star     Type .  Xorshift1024Star { T }   :   AbstractXorshift1024 { T }  Xorshift1024Star ([ seed ... ])   Xorshift1024Star RNG. The  seed  can be a  Tuple  of 16  UInt64 s, or several (no more than 16)  Integer s which will all be automatically converted to  UInt64  numbers.  source  #  RNG.Xorshifts.Xorshift128     Type .  Xorshift128 { T }   :   AbstractXorshift128 { T }  Xorshift128 ([ seed ])   Xorshift128 RNG. The  seed  can be a  Tuple  of two  UInt64 s, or an  Integer  which will be automatically convert to an  UInt128  number.  source  #  RNG.Xorshifts.Xorshift128Plus     Type .  Xorshift128Plus { T }   :   AbstractXorshift128 { T }  Xorshift128Plus ([ seed ])   Xorshift128Plus RNG. The  seed  can be a  Tuple  of two  UInt64 s, or an  Integer  which will be automatically convert to an  UInt128  number.  source  #  RNG.Xorshifts.Xorshift128Star     Type .  Xorshift128Star { T }   :   AbstractXorshift128 { T }  Xorshift128Star ([ seed ])   Xorshift128Star RNG. The  seed  can be a  Tuple  of two  UInt64 s, or an  Integer  which will be automatically convert to an  UInt128  number.  source  #  RNG.Xorshifts.Xorshift64     Type .  Xorshift64 { T }   :   AbstractXorshift64 { T }  Xorshift64 ([ seed ])   Xorshift64 RNG. The  seed  will be automatically convert to an  UInt64  number.  source  #  RNG.Xorshifts.Xorshift64Star     Type .  Xorshift64Star { T }   :   AbstractXorshift64 { T }  Xorshift64Star ([ seed ])   Xorshift64Star RNG. The  seed  will be automatically convert to an  UInt64  number.  source", 
            "title": "Public"
        }, 
        {
            "location": "/lib/xorshifts/#internal", 
            "text": "#  RNG.Xorshifts.AbstractXoroshiro128     Type .  AbstractXoroshiro128   :   AbstractRNG { UInt64 }   The base abstract type for  Xoroshiro128 ,  Xoroshiro128Star  and  Xoroshiro128Plus .  source  #  RNG.Xorshifts.AbstractXorshift1024     Type .  AbstractXorshift1024   :   AbstractRNG { UInt64 }   The base abstract type for  Xorshift1024 ,  Xorshift1024Star  and  Xorshift1024Plus .  source  #  RNG.Xorshifts.AbstractXorshift128     Type .  AbstractXorshift128   :   AbstractRNG { UInt64 }   The base abstract type for  Xorshift128 ,  Xorshift128Star  and  Xorshift128Plus .  source  #  RNG.Xorshifts.AbstractXorshift64     Type .  AbstractXorshift64   :   AbstractRNG { UInt64 }   The base abstract type for  Xorshift64  and  Xorshift64Star .  source  #  RNG.Xorshifts.xorshift_next     Function .  Do one iteration and get the current value of a Xorshift RNG object.  source", 
            "title": "Internal"
        }
    ]
}