{
    "docs": [
        {
            "location": "/", 
            "text": "RNG.jl Documentation\n\n\nRNG.jl\n is a collection of Random Number Generators for the Julia language.\n\n\nThere are several kinds of RNG families in this package, provided as submodules.\n\n\nThe examples and detailed descriptions of each RNG can be found on the Manual pages.\n\n\n\n\nManual Outline\n\n\n\n\nBases\n\n\nInstallation\n\n\nInterface\n\n\nEmpirical Statistical Testing\n\n\nConversion to Float\n\n\n\n\n\n\nPermuted Congruential Generators\n\n\nMersenne Twisters\n\n\nExamples\n\n\n\n\n\n\nRandom123 Family\n\n\nXorshift Family\n\n\n\n\n\n\nLibrary Outline\n\n\n\n\nRNG\n\n\nIndex\n\n\nPublic\n\n\nInternal\n\n\n\n\n\n\nPCG\n\n\nIndex\n\n\nPublic\n\n\nInternal\n\n\n\n\n\n\nMersenneTwisters\n\n\nIndex\n\n\nPublic\n\n\nInternal\n\n\n\n\n\n\nRandom123\n\n\nIndex\n\n\nPublic\n\n\nInternal\n\n\n\n\n\n\nXorshifts\n\n\nIndex\n\n\nPublic\n\n\nInternal", 
            "title": "Home"
        }, 
        {
            "location": "/#rngjl-documentation", 
            "text": "RNG.jl  is a collection of Random Number Generators for the Julia language.  There are several kinds of RNG families in this package, provided as submodules.  The examples and detailed descriptions of each RNG can be found on the Manual pages.", 
            "title": "RNG.jl Documentation"
        }, 
        {
            "location": "/#manual-outline", 
            "text": "Bases  Installation  Interface  Empirical Statistical Testing  Conversion to Float    Permuted Congruential Generators  Mersenne Twisters  Examples    Random123 Family  Xorshift Family", 
            "title": "Manual Outline"
        }, 
        {
            "location": "/#library-outline", 
            "text": "RNG  Index  Public  Internal    PCG  Index  Public  Internal    MersenneTwisters  Index  Public  Internal    Random123  Index  Public  Internal    Xorshifts  Index  Public  Internal", 
            "title": "Library Outline"
        }, 
        {
            "location": "/man/bases/", 
            "text": "Bases\n\n\nThis page describes basic concepts and fundanmental knowledge of \nRNG.jl\n.\n\n\n\n\nNote\n\n\nUnless otherwise specified, all the random number generators in this package are \npseudorandom\n number generators (or \ndeterministic\n random bit generator), which means they only provide numbers whose properties approximate the properties of \ntruly random\n numbers. Always, especially in secure-sensitive cases, keep in mind that they do not gaurantee a totally random performance.\n\n\n\n\n\n\nInstallation\n\n\nThis package is currently not registered, so you have to directly clone it for installation:\n\n\njulia\n \nPkg\n.\nclone\n(\nhttps://github.com/sunoru/RNG.jl.git\n)\n\n\n\n\n\n\nAnd build the dependencies:\n\n\njulia\n \nPkg\n.\nbuild\n(\nRNG\n)\n\n\n\n\n\n\nIt is recommended to run the test suites before using the package:\n\n\njulia\n \nPkg\n.\ntest\n(\nRNG\n)\n\n\n\n\n\n\n\n\nInterface\n\n\nFirst of all, to use a RNG from this package, you can import \nRNG.jl\n and use RNG by declare its submodule's name, or directly import the submodule. Then you can create a random number generator of certain type. For example:\n\n\njulia\n \nusing\n \nRNG\n\n\njulia\n \nr\n \n=\n \nXorshifts\n.\nXorshift1024Plus\n()\n\n\n\n\n\n\nor\n\n\njulia\n \nusing\n \nRNG\n.\nXorshifts\n\n\njulia\n \nr\n \n=\n \nXorshift1024Plus\n()\n\n\n\n\n\n\nThe submodules have some API in common and a few differently.\n\n\nAll the Random Number Generators (RNGs) are child types of \nAbstractRNG{T}\n, which is a child type of \nBase.Random.AbstractRNG\n and replaces it. (\nBase.Random\n may be refactored sometime, anyway.) The type parameter \nT\n indicates the original output type of a RNG, and it is usually a child type of \nUnsigned\n, such as \nUInt64\n, \nUInt32\n, etc. Users can change the output type of a certain RNG type by use a wrapped type: \nWrappedRNG\n.\n\n\nConsistent to what \nBase.Random\n does, there are generic functions:\n\n\n\n\nsrand(::AbstractRNG{T}[, seed])\n   initializes a RNG by one or a sequence of numbers (called \nseed\n). The output sequences by two RNGs of   the same type should be the same if they are initialized by the same seed, which makes them   \ndeterministic\n. The seed type of each RNG type can be different, you can refer to the corresponding   manual pages for details. If no \nseed\n provided, then it will use \nRNG.gen_seed\n to get a \"truly\"   random one.\n\n\nrand(::AbstractRNG{T}[, ::Type{TP}=Float64])\n   returns a random number in the type \nTP\n. \nTP\n is usually an \nUnsigned\n type, and the return value is   expected to be uniformly distributed in {0, 1} at every bit. When \nTP\n is \nFloat64\n (as default), this   function returns a \nFloat64\n value that is expected to be uniformly distributed in $[0, 1)$. The discussion   about this is in the \nConversion to Float\n section.\n\n\n\n\nThe other generic functions such as \nrand(::AbstractRNG, ::Dims)\n and \nrand!(::AbstractRNG, ::AbstractArray)\n defined in \nBase.Random\n still work.\n\n\nThe constructors of all the types of RNG are designed to take the same kind of parameters as \nsrand\n. For example:\n\n\njulia\n \nusing\n \nRNG\n.\nXorshifts\n\n\n\njulia\n \nr1\n \n=\n \nXorshift128Star\n(\n123\n)\n  \n# Create a RNG of Xorshift128Star with the seed \n123\n\n\nRNG.Xorshifts.Xorshift128Star(0x000000003a300074,0x000000003a30004e)\n\n\n\njulia\n \nr2\n \n=\n \nXorshift128Star\n();\n  \n# Use a random value to be the seed.\n\n\n\njulia\n \nrand\n(\nr1\n)\n  \n# Generate a number uniformly distributed in ``[0, 1)``.\n\n\n0.2552720033868119\n\n\n\njulia\n \nA\n \n=\n \nrand\n(\nr1\n,\n \nUInt64\n,\n \n2\n,\n \n3\n)\n  \n# Generate a 2x3 matrix `A` in `UInt64` type.\n\n\n2\u00d73 Array{UInt64,2}:\n\n\n 0xbed3dea863c65407  0x607f5f9815f515af  0x807289d8f9847407\n\n\n 0x4ab80d43269335ee  0xf78b56ada11ea641  0xc2306a55acfb4aaa\n\n\n\njulia\n \nrand!\n(\nr1\n,\n \nA\n)\n  \n# Refill `A` with random numbers.\n\n\n2\u00d73 Array{UInt64,2}:\n\n\n 0xf729352e2a72b541  0xe89948b5582a85f0  0x8a95ebd6aa34fcf4\n\n\n 0xc0c5a8df4c1b160f  0x8b5269ed6c790e08  0x930b89985ae0c865\n\n\n\n\n\n\nPeople will get the same results in their own computers of the above lines. For more interfaces and usage examples, please refer to the manual pages of each RNG.\n\n\n\n\nEmpirical Statistical Testing\n\n\nEmpirical statistical testing is very important for random number generation, because the theoretical mathematical analysis is insufficient to verify the performance of a random number generator.\n\n\nThe famous and highly evaluated \nTestU01\n library\n is chosen to test the RNGs in \nRNG.jl\n. \nTestU01\n offers a collection of test suites, and \nBig Crush\n is the largest and most stringent test battery for empirical testing (which usually takes several hours to run). \nBig Crush\n has revealed a number of flaws of lots of well-used generators, even including the \nMersenne Twister\n (or to be more exact, the \ndSFMT\n) which is currently used in \nBase.Random\n as \nGLOBAL_RAND\n.\n1\n\n\nThis package chooses \nRNGTest.jl\n to use TestU01.\n\n\nThe testing results are available on \nBenchmark\n page.\n\n\n\n\nConversion to Float\n\n\nBesides the statistical flaws, popular generators often neglect the importance of converting unsigned integers to floating numbers. The most common situation is to convert an \nUInt\n to a \nFloat64\n which is uniformly distributed in $[0.0, 1.0)$. For example, neither the \nstd::uniform_real_distribution\n in libstdc++ from gcc, libc++ from llvm, nor the standard library from MSVC has a correct performance, as they all have a non-zero probability for generating the max value which is an open bound and should not be produced.\n\n\nThe cause is that a \nFloat64\n number in $[0.0, 1.0)$ has only 53 \nsignificand\n bits (52 explicitly stored), which means at least 11 bits of an \nUInt64\n are abandoned when being converted to \nFloat64\n. If using the naive approach to multiply an \nUInt64\n by $2^{-64}$, users may get 1.0, and the distribution is not good (although using $2^{-32}$ for an \nUInt32\n is OK).\n\n\nIn this package, we make use of the fact that the distribution of the least 52 bits can be the same in an \nUInt64\n and a \nFloat64\n (if you are familiar with \nIEEE 754\n this is easy to understand). An \nUInt64\n will firstly be converted to a \nFloat64\n that is perfectly uniformly distributed in [1.0, 2.0), and then be minus by one. This is a very fast approach, but not completely ideal, since the one bit is wasted. The current default RNG in \nBase.Random\n library does the same thing, so it also causes some tricky problems.\n2\n\n\n\n\n\n\n\n\n\n\nrand\n fails bigcrush #6464\n\n\n\n\n\n\nLeast significant bit of rand() is always zero #16344", 
            "title": "Bases"
        }, 
        {
            "location": "/man/bases/#bases", 
            "text": "This page describes basic concepts and fundanmental knowledge of  RNG.jl .   Note  Unless otherwise specified, all the random number generators in this package are  pseudorandom  number generators (or  deterministic  random bit generator), which means they only provide numbers whose properties approximate the properties of  truly random  numbers. Always, especially in secure-sensitive cases, keep in mind that they do not gaurantee a totally random performance.", 
            "title": "Bases"
        }, 
        {
            "location": "/man/bases/#installation", 
            "text": "This package is currently not registered, so you have to directly clone it for installation:  julia   Pkg . clone ( https://github.com/sunoru/RNG.jl.git )   And build the dependencies:  julia   Pkg . build ( RNG )   It is recommended to run the test suites before using the package:  julia   Pkg . test ( RNG )", 
            "title": "Installation"
        }, 
        {
            "location": "/man/bases/#interface", 
            "text": "First of all, to use a RNG from this package, you can import  RNG.jl  and use RNG by declare its submodule's name, or directly import the submodule. Then you can create a random number generator of certain type. For example:  julia   using   RNG  julia   r   =   Xorshifts . Xorshift1024Plus ()   or  julia   using   RNG . Xorshifts  julia   r   =   Xorshift1024Plus ()   The submodules have some API in common and a few differently.  All the Random Number Generators (RNGs) are child types of  AbstractRNG{T} , which is a child type of  Base.Random.AbstractRNG  and replaces it. ( Base.Random  may be refactored sometime, anyway.) The type parameter  T  indicates the original output type of a RNG, and it is usually a child type of  Unsigned , such as  UInt64 ,  UInt32 , etc. Users can change the output type of a certain RNG type by use a wrapped type:  WrappedRNG .  Consistent to what  Base.Random  does, there are generic functions:   srand(::AbstractRNG{T}[, seed])    initializes a RNG by one or a sequence of numbers (called  seed ). The output sequences by two RNGs of   the same type should be the same if they are initialized by the same seed, which makes them    deterministic . The seed type of each RNG type can be different, you can refer to the corresponding   manual pages for details. If no  seed  provided, then it will use  RNG.gen_seed  to get a \"truly\"   random one.  rand(::AbstractRNG{T}[, ::Type{TP}=Float64])    returns a random number in the type  TP .  TP  is usually an  Unsigned  type, and the return value is   expected to be uniformly distributed in {0, 1} at every bit. When  TP  is  Float64  (as default), this   function returns a  Float64  value that is expected to be uniformly distributed in $[0, 1)$. The discussion   about this is in the  Conversion to Float  section.   The other generic functions such as  rand(::AbstractRNG, ::Dims)  and  rand!(::AbstractRNG, ::AbstractArray)  defined in  Base.Random  still work.  The constructors of all the types of RNG are designed to take the same kind of parameters as  srand . For example:  julia   using   RNG . Xorshifts  julia   r1   =   Xorshift128Star ( 123 )    # Create a RNG of Xorshift128Star with the seed  123  RNG.Xorshifts.Xorshift128Star(0x000000003a300074,0x000000003a30004e)  julia   r2   =   Xorshift128Star ();    # Use a random value to be the seed.  julia   rand ( r1 )    # Generate a number uniformly distributed in ``[0, 1)``.  0.2552720033868119  julia   A   =   rand ( r1 ,   UInt64 ,   2 ,   3 )    # Generate a 2x3 matrix `A` in `UInt64` type.  2\u00d73 Array{UInt64,2}:   0xbed3dea863c65407  0x607f5f9815f515af  0x807289d8f9847407   0x4ab80d43269335ee  0xf78b56ada11ea641  0xc2306a55acfb4aaa  julia   rand! ( r1 ,   A )    # Refill `A` with random numbers.  2\u00d73 Array{UInt64,2}:   0xf729352e2a72b541  0xe89948b5582a85f0  0x8a95ebd6aa34fcf4   0xc0c5a8df4c1b160f  0x8b5269ed6c790e08  0x930b89985ae0c865   People will get the same results in their own computers of the above lines. For more interfaces and usage examples, please refer to the manual pages of each RNG.", 
            "title": "Interface"
        }, 
        {
            "location": "/man/bases/#empirical-statistical-testing", 
            "text": "Empirical statistical testing is very important for random number generation, because the theoretical mathematical analysis is insufficient to verify the performance of a random number generator.  The famous and highly evaluated  TestU01  library  is chosen to test the RNGs in  RNG.jl .  TestU01  offers a collection of test suites, and  Big Crush  is the largest and most stringent test battery for empirical testing (which usually takes several hours to run).  Big Crush  has revealed a number of flaws of lots of well-used generators, even including the  Mersenne Twister  (or to be more exact, the  dSFMT ) which is currently used in  Base.Random  as  GLOBAL_RAND . 1  This package chooses  RNGTest.jl  to use TestU01.  The testing results are available on  Benchmark  page.", 
            "title": "Empirical Statistical Testing"
        }, 
        {
            "location": "/man/bases/#conversion-to-float", 
            "text": "Besides the statistical flaws, popular generators often neglect the importance of converting unsigned integers to floating numbers. The most common situation is to convert an  UInt  to a  Float64  which is uniformly distributed in $[0.0, 1.0)$. For example, neither the  std::uniform_real_distribution  in libstdc++ from gcc, libc++ from llvm, nor the standard library from MSVC has a correct performance, as they all have a non-zero probability for generating the max value which is an open bound and should not be produced.  The cause is that a  Float64  number in $[0.0, 1.0)$ has only 53  significand  bits (52 explicitly stored), which means at least 11 bits of an  UInt64  are abandoned when being converted to  Float64 . If using the naive approach to multiply an  UInt64  by $2^{-64}$, users may get 1.0, and the distribution is not good (although using $2^{-32}$ for an  UInt32  is OK).  In this package, we make use of the fact that the distribution of the least 52 bits can be the same in an  UInt64  and a  Float64  (if you are familiar with  IEEE 754  this is easy to understand). An  UInt64  will firstly be converted to a  Float64  that is perfectly uniformly distributed in [1.0, 2.0), and then be minus by one. This is a very fast approach, but not completely ideal, since the one bit is wasted. The current default RNG in  Base.Random  library does the same thing, so it also causes some tricky problems. 2      rand  fails bigcrush #6464    Least significant bit of rand() is always zero #16344", 
            "title": "Conversion to Float"
        }, 
        {
            "location": "/man/benchmark/", 
            "text": "Benchmark\n\n\nThis page includes the results of speed tests and big crush tests of several kinds of RNGs in this package. The data is produced on such a computer:\n\n\njulia\n \nversioninfo\n()\n\n\nJulia\n \nVersion\n \n0.5\n.\n0\n-\nrc0\n+\n0\n\n\nCommit\n \n633443\nc\n \n(\n2016\n-\n08\n-\n02\n \n00\n:\n53\n \nUTC\n)\n\n\nPlatform\n \nInfo\n:\n\n  \nSystem\n:\n \nLinux\n \n(\nx86_64\n-\nredhat\n-\nlinux\n)\n\n  \nCPU\n:\n \nIntel\n(\nR\n)\n \nCore\n(\nTM\n)\n \ni5\n-\n3470\n \nCPU\n \n@\n \n3.20\nGHz\n\n  \nWORD_SIZE\n:\n \n64\n\n  \nBLAS\n:\n \nlibopenblas\n \n(\nUSE64BITINT\n \nDYNAMIC_ARCH\n \nNO_AFFINITY\n \nSandybridge\n)\n\n  \nLAPACK\n:\n \nlibopenblas64_\n\n  \nLIBM\n:\n \nlibopenlibm\n\n  \nLLVM\n:\n \nlibLLVM\n-\n3.7\n.\n1\n \n(\nORCJIT\n,\n \nivybridge\n)\n\n\n\n\n\n\nAll the benchmark scripts are in the \nbenchmark\n directory, you can do the tests by yourself.\n\n\n\n\nNote\n\n\nAll the data here is only for reference, and will be updated as this package is updated.\n\n\n\n\n\n\nSpeed Test\n\n\nThe speed test results are as following (the smaller is the better):\n\n\n\n\nand detailed in the table (sorted by speed):\n\n\n\n\n\n\n\n\nRNG Type\n\n\nSpeed (ns/64 bits)\n\n\nRNG Type\n\n\nSpeed (ns/64 bits)\n\n\nRNG Type\n\n\nSpeed (ns/64 bits)\n\n\n\n\n\n\n\n\n\n\nXoroshiro128Star\n\n\n1.184\n\n\nPCG_XSL_RR_128\n\n\n2.646\n\n\nPhilox4x64\n\n\n5.737\n\n\n\n\n\n\nXorshift128Plus\n\n\n1.189\n\n\nPCG_XSH_RS_64\n\n\n2.738\n\n\nThreefry4x64\n\n\n5.965\n\n\n\n\n\n\nXoroshiro128Plus\n\n\n1.393\n\n\nPCG_XSH_RR_128\n\n\n3.260\n\n\nThreefry2x64\n\n\n7.760\n\n\n\n\n\n\nXorshift128Star\n\n\n1.486\n\n\nPCG_XSL_RR_64\n\n\n3.308\n\n\nPhilox2x32\n\n\n9.698\n\n\n\n\n\n\nPCG_RXS_M_XS_64\n\n\n1.522\n\n\nPCG_XSH_RS_128\n\n\n3.373\n\n\nPhilox4x32\n\n\n11.517\n\n\n\n\n\n\nPCG_XSL_RR_RR_128\n\n\n1.602\n\n\nPCG_RXS_M_XS_32\n\n\n3.420\n\n\nThreefry4x32\n\n\n12.241\n\n\n\n\n\n\nXorshift64\n\n\n1.918\n\n\nPCG_XSH_RR_64\n\n\n3.580\n\n\nThreefry2x32\n\n\n16.253\n\n\n\n\n\n\nBaseMT19937*\n\n\n1.971\n\n\nXorshift1024Plus\n\n\n3.725\n\n\nARS1x128\n\n\n17.081\n\n\n\n\n\n\nXorshift64Star\n\n\n2.000\n\n\nXorshift1024Star\n\n\n3.748\n\n\nARS4x32\n\n\n18.059\n\n\n\n\n\n\nPCG_XSL_RR_RR_64\n\n\n2.044\n\n\nMT19937\n\n\n4.229\n\n\nAESNI1x128\n\n\n18.304\n\n\n\n\n\n\nPCG_RXS_M_XS_128\n\n\n2.482\n\n\nPhilox2x64\n\n\n5.161\n\n\nAESNI4x32\n\n\n29.770\n\n\n\n\n\n\n\n\n*\nBaseMT19937\n denotes to \nBase.Random.MersenneTwister\n.\n\n\n\n\nBig Crush Test\n\n\n10 kinds of RNGs (which are worth considering) have been tested with Big Crush test batteries: |RNG Type|Speed (ns/64 bits)|Total CPU time|Failed Test(s)| |\u2013-|:-:|:-:|\u2013-| |\nAESNI1x128\n|18.304|04:14:22.19| | |\nARS1x128\n|17.081|04:13:27.54|55  SampleCorr, k = 1  7.0e-4| |\nBaseMT19937\n|1.971|03:18:23.47| | |\nMT19937\n|4.229|03:32:59.06|36  Gap, r = 0  eps\n80  LinearComp, r = 0  1 - eps1\n     81  LinearComp, r = 29  1 - eps1| |\nPCG\\_RXS\\_M\\_XS\\_64\\_64\n|1.522|03:23:44.44|21  BirthdaySpacings, t = 16  0.9994| |\nPCG\\_XSH\\_RS\\_128\\_64\n|3.373|03:40:54.73|73  GCD  8.4e-4| |\nPhilox2x64\n|5.737|03:28:52.27|35  Gap, r = 25  3.4e-4| |\nThreefry2x64\n|5.965|03:37:53.53| | |\nXoroshiro128Plus\n|1.393|03:33:16.51| | |\nXorshift1024Star\n|3.748|03:39:15.19| | eps  means a value \n 1.0e-300, and eps1 means a value \n 1.0e-15.\n\n\nIt is interesting that BaseMT19937 passes all the tests when generating \nUInt64\n (by generating two \nUInt32\n with dSFMT). The PCG ones do not pass all the tests as the paper says, but the failures are just near the threshold. The RNG with best performance here is \nXoroshiro128Plus\n, which passes all the tests and has an excellent speed.", 
            "title": "Benchmark"
        }, 
        {
            "location": "/man/benchmark/#benchmark", 
            "text": "This page includes the results of speed tests and big crush tests of several kinds of RNGs in this package. The data is produced on such a computer:  julia   versioninfo ()  Julia   Version   0.5 . 0 - rc0 + 0  Commit   633443 c   ( 2016 - 08 - 02   00 : 53   UTC )  Platform   Info : \n   System :   Linux   ( x86_64 - redhat - linux ) \n   CPU :   Intel ( R )   Core ( TM )   i5 - 3470   CPU   @   3.20 GHz \n   WORD_SIZE :   64 \n   BLAS :   libopenblas   ( USE64BITINT   DYNAMIC_ARCH   NO_AFFINITY   Sandybridge ) \n   LAPACK :   libopenblas64_ \n   LIBM :   libopenlibm \n   LLVM :   libLLVM - 3.7 . 1   ( ORCJIT ,   ivybridge )   All the benchmark scripts are in the  benchmark  directory, you can do the tests by yourself.   Note  All the data here is only for reference, and will be updated as this package is updated.", 
            "title": "Benchmark"
        }, 
        {
            "location": "/man/benchmark/#speed-test", 
            "text": "The speed test results are as following (the smaller is the better):   and detailed in the table (sorted by speed):     RNG Type  Speed (ns/64 bits)  RNG Type  Speed (ns/64 bits)  RNG Type  Speed (ns/64 bits)      Xoroshiro128Star  1.184  PCG_XSL_RR_128  2.646  Philox4x64  5.737    Xorshift128Plus  1.189  PCG_XSH_RS_64  2.738  Threefry4x64  5.965    Xoroshiro128Plus  1.393  PCG_XSH_RR_128  3.260  Threefry2x64  7.760    Xorshift128Star  1.486  PCG_XSL_RR_64  3.308  Philox2x32  9.698    PCG_RXS_M_XS_64  1.522  PCG_XSH_RS_128  3.373  Philox4x32  11.517    PCG_XSL_RR_RR_128  1.602  PCG_RXS_M_XS_32  3.420  Threefry4x32  12.241    Xorshift64  1.918  PCG_XSH_RR_64  3.580  Threefry2x32  16.253    BaseMT19937*  1.971  Xorshift1024Plus  3.725  ARS1x128  17.081    Xorshift64Star  2.000  Xorshift1024Star  3.748  ARS4x32  18.059    PCG_XSL_RR_RR_64  2.044  MT19937  4.229  AESNI1x128  18.304    PCG_RXS_M_XS_128  2.482  Philox2x64  5.161  AESNI4x32  29.770     * BaseMT19937  denotes to  Base.Random.MersenneTwister .", 
            "title": "Speed Test"
        }, 
        {
            "location": "/man/benchmark/#big-crush-test", 
            "text": "10 kinds of RNGs (which are worth considering) have been tested with Big Crush test batteries: |RNG Type|Speed (ns/64 bits)|Total CPU time|Failed Test(s)| |\u2013-|:-:|:-:|\u2013-| | AESNI1x128 |18.304|04:14:22.19| | | ARS1x128 |17.081|04:13:27.54|55  SampleCorr, k = 1  7.0e-4| | BaseMT19937 |1.971|03:18:23.47| | | MT19937 |4.229|03:32:59.06|36  Gap, r = 0  eps 80  LinearComp, r = 0  1 - eps1      81  LinearComp, r = 29  1 - eps1| | PCG\\_RXS\\_M\\_XS\\_64\\_64 |1.522|03:23:44.44|21  BirthdaySpacings, t = 16  0.9994| | PCG\\_XSH\\_RS\\_128\\_64 |3.373|03:40:54.73|73  GCD  8.4e-4| | Philox2x64 |5.737|03:28:52.27|35  Gap, r = 25  3.4e-4| | Threefry2x64 |5.965|03:37:53.53| | | Xoroshiro128Plus |1.393|03:33:16.51| | | Xorshift1024Star |3.748|03:39:15.19| | eps  means a value   1.0e-300, and eps1 means a value   1.0e-15.  It is interesting that BaseMT19937 passes all the tests when generating  UInt64  (by generating two  UInt32  with dSFMT). The PCG ones do not pass all the tests as the paper says, but the failures are just near the threshold. The RNG with best performance here is  Xoroshiro128Plus , which passes all the tests and has an excellent speed.", 
            "title": "Big Crush Test"
        }, 
        {
            "location": "/man/pcg/", 
            "text": "Permuted Congruential Generators", 
            "title": "PCG Family"
        }, 
        {
            "location": "/man/pcg/#permuted-congruential-generators", 
            "text": "", 
            "title": "Permuted Congruential Generators"
        }, 
        {
            "location": "/man/mersenne-twisters/", 
            "text": "Mersenne Twisters\n\n\nThe \nMersenne Twister\n1\n is so far the most widely used PRNG. Mersenne Twisters are taken as default random number generators of a great many of software systems, including the Julia language until the current 0.5 version. The most commonly used version of Mersenne Twisters is \nMT19937\n, which has a very long period of $2^{19937}-1$ and passes numerous tests including the Diehard tests.\n\n\nHowever, it also has many flaws by today's standards. For the large period, MT19937 has to use a 2.5 KiB state buffer, which place a load on the memory caches. More severely, it cannot pass all the TestU01 statistical tests\n2\n, and the speed is not so fast. \nSo it is not recommended in most situations.\n\n\nThe \nMersenneTwisters\n in this package currently only provides one RNG: \nMT19937\n. \nMT19937\n can only produce \nUInt32\n numbers as output. Its state is an array of 624 \nUInt32\n numbers, so it takes 624 \nUInt32\ns as seed. A default function is also provided to deal with one \nUInt32\n as seed.\n\n\n\n\nExamples\n\n\nTo use the Mersenne Twisters, firstly import the module:\n\n\njulia\n \nusing\n \nRNG\n.\nMersenneTwisters\n\n\n\n\n\n\nA certain sequence can be used to initialize an instance of MT19937:\n\n\njulia\n \nseed\n \n=\n \n((\nUInt32\n(\ni\n)\n \nfor\n \ni\n \nin\n \n1\n:\n624\n)\n...\n);\n  \n# This is a Tuple of 1..624\n\n\n\njulia\n \nr\n \n=\n \nMT19937\n(\nseed\n);\n\n\n\n\n\n\nSince MT19937 is a RNG based on linear-feedback shift-register techniques, this approach is not recommended for an obivous reason:\n\n\njulia\n \nrand\n(\nr\n,\n \nUInt32\n,\n \n10\n)\n\n\n10\n-\nelement\n \nArray\n{\nUInt32\n,\n1\n}:\n\n \n0x0000018f\n\n \n0x983ba049\n\n \n0x00000192\n\n \n0x983ba054\n\n \n0x00000191\n\n \n0x983ba057\n\n \n0x00000190\n\n \n0x983ba056\n\n \n0x00000193\n\n \n0x983ba055\n\n\n\n\n\n\nThe firstly generated numbers are so poorly random. This is because the most bits of states are zeros. So it is better to create a \nMT19937\n in this way:\n\n\njulia\n \nr\n \n=\n \nMT19937\n();\n\n\n\n\n\n\nIn this case, all the 624 states will be filled with truly random numbers produced by \nRandomDevice\n. If someone needs the reproducibility, just save the state \nr.mt\n and use it for next time.\n\n\nAn initialization function described in the original paper\n1\n is also implemented here, so the seed can also be just one \nUInt32\n number (or an \nInteger\n whose least 32 bits will be truncated):\n\n\njulia\n \nsrand\n(\nr\n,\n \n0xabcdef12\n);\n\n\n\njulia\n \nrand\n(\nr\n,\n \nUInt32\n,\n \n10\n)\n\n\n10\n-\nelement\n \nArray\n{\nUInt32\n,\n1\n}:\n\n \n0x63ec7b30\n\n \n0x71b2167e\n\n \n0x6c339700\n\n \n0x1cfaa505\n\n \n0xc7a81f4d\n\n \n0x3319b105\n\n \n0x457db8ba\n\n \n0xc9d4ccd8\n\n \n0x811f30a0\n\n \n0x627ecfbe\n\n\n\n\n\n\nNote that if you use one \nUInt32\n number as seed, you will always get in a bias way.\n3\n\n\n\n\n\n\n\n\n\n\nMatsumoto M, Nishimura T. Mersenne twister: a 623-dimensionally equidistributed uniform pseudo-random number generator[J]. ACM Transactions on Modeling and Computer Simulation (TOMACS), 1998, 8(1): 3-30. doi:\n10.1145/272991.272995\n.\n\n\n\n\n\n\nL'Ecuyer P, Simard R. TestU01: AC library for empirical testing of random number generators[J]. ACM Transactions on Mathematical Software (TOMS), 2007, 33(4): 22. doi: \n10.1145/1268776.1268777\n\n\n\n\n\n\nC++ Seeding Surprises", 
            "title": "Mersenne Twisters"
        }, 
        {
            "location": "/man/mersenne-twisters/#mersenne-twisters", 
            "text": "The  Mersenne Twister 1  is so far the most widely used PRNG. Mersenne Twisters are taken as default random number generators of a great many of software systems, including the Julia language until the current 0.5 version. The most commonly used version of Mersenne Twisters is  MT19937 , which has a very long period of $2^{19937}-1$ and passes numerous tests including the Diehard tests.  However, it also has many flaws by today's standards. For the large period, MT19937 has to use a 2.5 KiB state buffer, which place a load on the memory caches. More severely, it cannot pass all the TestU01 statistical tests 2 , and the speed is not so fast.  So it is not recommended in most situations.  The  MersenneTwisters  in this package currently only provides one RNG:  MT19937 .  MT19937  can only produce  UInt32  numbers as output. Its state is an array of 624  UInt32  numbers, so it takes 624  UInt32 s as seed. A default function is also provided to deal with one  UInt32  as seed.", 
            "title": "Mersenne Twisters"
        }, 
        {
            "location": "/man/mersenne-twisters/#examples", 
            "text": "To use the Mersenne Twisters, firstly import the module:  julia   using   RNG . MersenneTwisters   A certain sequence can be used to initialize an instance of MT19937:  julia   seed   =   (( UInt32 ( i )   for   i   in   1 : 624 ) ... );    # This is a Tuple of 1..624  julia   r   =   MT19937 ( seed );   Since MT19937 is a RNG based on linear-feedback shift-register techniques, this approach is not recommended for an obivous reason:  julia   rand ( r ,   UInt32 ,   10 )  10 - element   Array { UInt32 , 1 }: \n  0x0000018f \n  0x983ba049 \n  0x00000192 \n  0x983ba054 \n  0x00000191 \n  0x983ba057 \n  0x00000190 \n  0x983ba056 \n  0x00000193 \n  0x983ba055   The firstly generated numbers are so poorly random. This is because the most bits of states are zeros. So it is better to create a  MT19937  in this way:  julia   r   =   MT19937 ();   In this case, all the 624 states will be filled with truly random numbers produced by  RandomDevice . If someone needs the reproducibility, just save the state  r.mt  and use it for next time.  An initialization function described in the original paper 1  is also implemented here, so the seed can also be just one  UInt32  number (or an  Integer  whose least 32 bits will be truncated):  julia   srand ( r ,   0xabcdef12 );  julia   rand ( r ,   UInt32 ,   10 )  10 - element   Array { UInt32 , 1 }: \n  0x63ec7b30 \n  0x71b2167e \n  0x6c339700 \n  0x1cfaa505 \n  0xc7a81f4d \n  0x3319b105 \n  0x457db8ba \n  0xc9d4ccd8 \n  0x811f30a0 \n  0x627ecfbe   Note that if you use one  UInt32  number as seed, you will always get in a bias way. 3      Matsumoto M, Nishimura T. Mersenne twister: a 623-dimensionally equidistributed uniform pseudo-random number generator[J]. ACM Transactions on Modeling and Computer Simulation (TOMACS), 1998, 8(1): 3-30. doi: 10.1145/272991.272995 .    L'Ecuyer P, Simard R. TestU01: AC library for empirical testing of random number generators[J]. ACM Transactions on Mathematical Software (TOMS), 2007, 33(4): 22. doi:  10.1145/1268776.1268777    C++ Seeding Surprises", 
            "title": "Examples"
        }, 
        {
            "location": "/man/random123/", 
            "text": "Random123 Family", 
            "title": "Random123 Family"
        }, 
        {
            "location": "/man/random123/#random123-family", 
            "text": "", 
            "title": "Random123 Family"
        }, 
        {
            "location": "/man/xorshifts/", 
            "text": "Xorshift Family", 
            "title": "Xorshift Family"
        }, 
        {
            "location": "/man/xorshifts/#xorshift-family", 
            "text": "", 
            "title": "Xorshift Family"
        }, 
        {
            "location": "/man/ref/", 
            "text": "Reference", 
            "title": "Reference"
        }, 
        {
            "location": "/man/ref/#reference", 
            "text": "", 
            "title": "Reference"
        }, 
        {
            "location": "/lib/rng/", 
            "text": "RNG\n\n\n\n\nIndex\n\n\n\n\nRNG\n\n\nRNG.AbstractRNG\n\n\nRNG.WrappedRNG\n\n\nRNG.gen_seed\n\n\nRNG.output_type\n\n\n\n\n\n\nPublic\n\n\n#\n\n\nRNG\n \n \nModule\n.\n\n\nMain module for \nRNG.jl\n \u2013 a random number generator package for Julia Language.\n\n\nThis module exports two types and four submodules:\n\n\n\n\nAbstractRNG\n.\n\n\nWrappedRNG\n.\n\n\nPCG\n.\n\n\nMersenneTwisters\n.\n\n\nRandom123\n.\n\n\nXorshifts\n.\n\n\n\n\nsource\n\n\n#\n\n\nRNG.AbstractRNG\n \n \nType\n.\n\n\nAbstractRNG\n{\nT\n}\n \n:\n \nBase\n.\nRandom\n.\nAbstractRNG\n\n\n\n\n\n\nThe abstract type of Random Number Generators. T indicates the original output type of a RNG.\n\n\nsource\n\n\n#\n\n\nRNG.WrappedRNG\n \n \nType\n.\n\n\nWrappedRNG\n{\nR\n,\n \nT1\n,\n \nT2\n}\n \n:\n \nAbstractRNG\n{\nT2\n}\n\n\nWrappedRNG\n(\nbase_rng\n,\n \nT2\n)\n\n\nWrappedRNG\n(\nR\n,\n \nT2\n,\n \nargs\n...\n)\n\n\n\n\n\n\nWrap a RNG which originally provides output in T1 into a RNG that provides output in T2.\n\n\nExamples\n\n\njulia\n \nr\n \n=\n \nXorshifts\n.\nXorshift128Star\n(\n123\n);\n\n\n\njulia\n \nRNG\n.\noutput_type\n(\nr\n)\n\n\nUInt64\n\n\n\njulia\n \nr1\n \n=\n \nWrappedRNG\n(\nr\n,\n \nUInt32\n);\n\n\n\njulia\n \nRNG\n.\noutput_type\n(\nr1\n)\n\n\nUInt32\n\n\n\njulia\n \nr2\n \n=\n \nWrappedRNG\n(\nXorshifts\n.\nXorshift128Star\n,\n \nUInt32\n,\n \n123\n);\n\n\n\njulia\n \nRNG\n.\noutput_type\n(\nr2\n)\n\n\nUInt32\n\n\n\njulia\n \n@\nTest\n.\ntest\n \nrand\n(\nr1\n,\n \nUInt32\n,\n \n3\n)\n \n==\n \nrand\n(\nr2\n,\n \nUInt32\n,\n \n3\n)\n\n\nTest Passed\n\n\n  Expression: rand(r1,UInt32,3) == rand(r2,UInt32,3)\n\n\n   Evaluated: UInt32[0x18a21796,0x20241598,0x63c65407] == UInt32[0x18a21796,0x20241598,0x63c65407]\n\n\n\n\n\n\nsource\n\n\n\n\nInternal\n\n\n#\n\n\nRNG.gen_seed\n \n \nMethod\n.\n\n\ngen_seed\n(\nT\n[,\n \nn\n])\n\n\n\n\n\n\nGenerate a tuple of \nn\n truly random numbers in type \nT\n. If \nn\n is missing, return only one number. The \"truly\" random numbers are provided by the random device of system. See \nBase.Random.RandomDevice\n.\n\n\nExamples\n\n\njulia\n \nRNG\n.\ngen_seed\n(\nUInt64\n,\n \n2\n)\n  \n# The output should probably be different on different computers.\n\n\n(\n0x26aa3fe5e306f725\n,\n0x7b9dc3c227d8acc9\n)\n\n\n\njulia\n \nRNG\n.\ngen_seed\n(\nUInt32\n)\n\n\n0x9ba60fdc\n\n\n\n\n\n\nsource\n\n\n#\n\n\nRNG.output_type\n \n \nMethod\n.\n\n\nGet the original output type of a RNG.\n\n\nsource", 
            "title": "RNG"
        }, 
        {
            "location": "/lib/rng/#rng", 
            "text": "", 
            "title": "RNG"
        }, 
        {
            "location": "/lib/rng/#index", 
            "text": "RNG  RNG.AbstractRNG  RNG.WrappedRNG  RNG.gen_seed  RNG.output_type", 
            "title": "Index"
        }, 
        {
            "location": "/lib/rng/#public", 
            "text": "#  RNG     Module .  Main module for  RNG.jl  \u2013 a random number generator package for Julia Language.  This module exports two types and four submodules:   AbstractRNG .  WrappedRNG .  PCG .  MersenneTwisters .  Random123 .  Xorshifts .   source  #  RNG.AbstractRNG     Type .  AbstractRNG { T }   :   Base . Random . AbstractRNG   The abstract type of Random Number Generators. T indicates the original output type of a RNG.  source  #  RNG.WrappedRNG     Type .  WrappedRNG { R ,   T1 ,   T2 }   :   AbstractRNG { T2 }  WrappedRNG ( base_rng ,   T2 )  WrappedRNG ( R ,   T2 ,   args ... )   Wrap a RNG which originally provides output in T1 into a RNG that provides output in T2.  Examples  julia   r   =   Xorshifts . Xorshift128Star ( 123 );  julia   RNG . output_type ( r )  UInt64  julia   r1   =   WrappedRNG ( r ,   UInt32 );  julia   RNG . output_type ( r1 )  UInt32  julia   r2   =   WrappedRNG ( Xorshifts . Xorshift128Star ,   UInt32 ,   123 );  julia   RNG . output_type ( r2 )  UInt32  julia   @ Test . test   rand ( r1 ,   UInt32 ,   3 )   ==   rand ( r2 ,   UInt32 ,   3 )  Test Passed    Expression: rand(r1,UInt32,3) == rand(r2,UInt32,3)     Evaluated: UInt32[0x18a21796,0x20241598,0x63c65407] == UInt32[0x18a21796,0x20241598,0x63c65407]   source", 
            "title": "Public"
        }, 
        {
            "location": "/lib/rng/#internal", 
            "text": "#  RNG.gen_seed     Method .  gen_seed ( T [,   n ])   Generate a tuple of  n  truly random numbers in type  T . If  n  is missing, return only one number. The \"truly\" random numbers are provided by the random device of system. See  Base.Random.RandomDevice .  Examples  julia   RNG . gen_seed ( UInt64 ,   2 )    # The output should probably be different on different computers.  ( 0x26aa3fe5e306f725 , 0x7b9dc3c227d8acc9 )  julia   RNG . gen_seed ( UInt32 )  0x9ba60fdc   source  #  RNG.output_type     Method .  Get the original output type of a RNG.  source", 
            "title": "Internal"
        }, 
        {
            "location": "/lib/pcg/", 
            "text": "PCG\n\n\n\n\nIndex\n\n\n\n\nRNG.PCG\n\n\nRNG.PCG.PCGMethod\n\n\nRNG.PCG.PCG_LIST\n\n\nRNG.PCG.AbstractPCG\n\n\nRNG.PCG.PCGStateMCG\n\n\nRNG.PCG.PCGStateOneseq\n\n\nRNG.PCG.PCGStateSetseq\n\n\nRNG.PCG.PCGStateUnique\n\n\nRNG.PCG.advance!\n\n\nRNG.PCG.bounded_rand\n\n\nRNG.PCG.default_increment\n\n\nRNG.PCG.default_multiplier\n\n\nRNG.PCG.mcg_multiplier\n\n\nRNG.PCG.mcg_unmultiplier\n\n\nRNG.PCG.pcg_advance!\n\n\nRNG.PCG.pcg_advance_lcg\n\n\nRNG.PCG.pcg_output\n\n\nRNG.PCG.pcg_srand\n\n\nRNG.PCG.pcg_step!\n\n\n\n\n\n\nPublic\n\n\n#\n\n\nRNG.PCG\n \n \nModule\n.\n\n\nThe module for \nPCG Family\n.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.PCGMethod\n \n \nConstant\n.\n\n\nThe \nUnion\n of all the PCG method types: \nPCG_XSH_RS\n, \nPCG_XSH_RR\n, \nPCG_RXS_M_XS\n, \nPCG_XSL_RR\n, and \nPCG_XSL_RR_RR\n.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.PCG_LIST\n \n \nConstant\n.\n\n\nThe list of all the parameter combinations that can be used for PCG.\n\n\n\n\n\n\n\n\nStream variation\n\n\nState Type\n\n\nMethod Type\n\n\nOutput Type\n\n\n\n\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt16\n\n\nPCG_XSH_RS\n\n\nUInt8\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt32\n\n\nPCG_XSH_RS\n\n\nUInt16\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt64\n\n\nPCG_XSH_RS\n\n\nUInt32\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt128\n\n\nPCG_XSH_RS\n\n\nUInt64\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt16\n\n\nPCG_XSH_RS\n\n\nUInt8\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt32\n\n\nPCG_XSH_RS\n\n\nUInt16\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt64\n\n\nPCG_XSH_RS\n\n\nUInt32\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt128\n\n\nPCG_XSH_RS\n\n\nUInt64\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt16\n\n\nPCG_XSH_RS\n\n\nUInt8\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt32\n\n\nPCG_XSH_RS\n\n\nUInt16\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt64\n\n\nPCG_XSH_RS\n\n\nUInt32\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt128\n\n\nPCG_XSH_RS\n\n\nUInt64\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt16\n\n\nPCG_XSH_RS\n\n\nUInt8\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt32\n\n\nPCG_XSH_RS\n\n\nUInt16\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt64\n\n\nPCG_XSH_RS\n\n\nUInt32\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt128\n\n\nPCG_XSH_RS\n\n\nUInt64\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt16\n\n\nPCG_XSH_RR\n\n\nUInt8\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt32\n\n\nPCG_XSH_RR\n\n\nUInt16\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt64\n\n\nPCG_XSH_RR\n\n\nUInt32\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt128\n\n\nPCG_XSH_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt16\n\n\nPCG_XSH_RR\n\n\nUInt8\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt32\n\n\nPCG_XSH_RR\n\n\nUInt16\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt64\n\n\nPCG_XSH_RR\n\n\nUInt32\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt128\n\n\nPCG_XSH_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt16\n\n\nPCG_XSH_RR\n\n\nUInt8\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt32\n\n\nPCG_XSH_RR\n\n\nUInt16\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt64\n\n\nPCG_XSH_RR\n\n\nUInt32\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt128\n\n\nPCG_XSH_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt16\n\n\nPCG_XSH_RR\n\n\nUInt8\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt32\n\n\nPCG_XSH_RR\n\n\nUInt16\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt64\n\n\nPCG_XSH_RR\n\n\nUInt32\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt128\n\n\nPCG_XSH_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt8\n\n\nPCG_RXS_M_XS\n\n\nUInt8\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt16\n\n\nPCG_RXS_M_XS\n\n\nUInt16\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt32\n\n\nPCG_RXS_M_XS\n\n\nUInt32\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt64\n\n\nPCG_RXS_M_XS\n\n\nUInt64\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt128\n\n\nPCG_RXS_M_XS\n\n\nUInt128\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt16\n\n\nPCG_RXS_M_XS\n\n\nUInt16\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt32\n\n\nPCG_RXS_M_XS\n\n\nUInt32\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt64\n\n\nPCG_RXS_M_XS\n\n\nUInt64\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt128\n\n\nPCG_RXS_M_XS\n\n\nUInt128\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt8\n\n\nPCG_RXS_M_XS\n\n\nUInt8\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt16\n\n\nPCG_RXS_M_XS\n\n\nUInt16\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt32\n\n\nPCG_RXS_M_XS\n\n\nUInt32\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt64\n\n\nPCG_RXS_M_XS\n\n\nUInt64\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt128\n\n\nPCG_RXS_M_XS\n\n\nUInt128\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt64\n\n\nPCG_XSL_RR\n\n\nUInt32\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt128\n\n\nPCG_XSL_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt64\n\n\nPCG_XSL_RR\n\n\nUInt32\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt128\n\n\nPCG_XSL_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt64\n\n\nPCG_XSL_RR\n\n\nUInt32\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt128\n\n\nPCG_XSL_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt64\n\n\nPCG_XSL_RR\n\n\nUInt32\n\n\n\n\n\n\nPCGStateMCG\n\n\nUInt128\n\n\nPCG_XSL_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt64\n\n\nPCG_XSL_RR_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateOneseq\n\n\nUInt128\n\n\nPCG_XSL_RR_RR\n\n\nUInt128\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt64\n\n\nPCG_XSL_RR_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateUnique\n\n\nUInt128\n\n\nPCG_XSL_RR_RR\n\n\nUInt128\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt64\n\n\nPCG_XSL_RR_RR\n\n\nUInt64\n\n\n\n\n\n\nPCGStateSetseq\n\n\nUInt128\n\n\nPCG_XSL_RR_RR\n\n\nUInt128\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nRNG.PCG.PCGStateMCG\n \n \nType\n.\n\n\nPCGStateMCG\n{\nStateType\n:\nPCGUInt\n,\n \nMethodType\n:\nPCGMethod\n,\n \nOutputType\n:\nPCGUInt\n}\n \n:\n\n    \nAbstractPCG\n{\nStateType\n,\n \nMethodType\n,\n \nOutputType\n}\n\n\nPCGStateMCG\n([\nseed\n])\n\n\nPCGStateMCG\n(\noutput_type\n[,\n \nseed\n])\n\n\nPCGStateMCG\n(\nmethod\n[,\n \nseed\n])\n\n\nPCGStateMCG\n(\noutput_type\n[,\n \nmethod\n,\n \nseed\n])\n\n\n\n\n\n\nPCG generator with \nMCG\n, where the increment is zero, resulting in a single stream and reduced period.\n\n\nseed\n is an \nInteger\n which will be automatically converted to the state type.\n\n\noutput_type\n is the type of the PCG's output. If missing it is set to \nUInt64\n.\n\n\nmethod\n is one of the \nPCGMethod\n. If missing it is set to \nPCG_XSH_RS\n.\n\n\nSee \nPCG_LIST\n for the available parameter combinations.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.PCGStateOneseq\n \n \nType\n.\n\n\nPCGStateOneseq\n{\nStateType\n:\nPCGUInt\n,\n \nMethodType\n:\nPCGMethod\n,\n \nOutputType\n:\nPCGUInt\n}\n \n:\n\n    \nAbstractPCG\n{\nStateType\n,\n \nMethodType\n,\n \nOutputType\n}\n\n\nPCGStateOneseq\n([\nseed\n])\n\n\nPCGStateOneseq\n(\noutput_type\n[,\n \nseed\n])\n\n\nPCGStateOneseq\n(\nmethod\n[,\n \nseed\n])\n\n\nPCGStateOneseq\n(\noutput_type\n[,\n \nmethod\n,\n \nseed\n])\n\n\n\n\n\n\nPCG generator with \nsingle streams\n, where all instances use the same fixed constant, thus the RNG always somewhere in same sequence.\n\n\nseed\n is an \nInteger\n which will be automatically converted to the state type.\n\n\noutput_type\n is the type of the PCG's output. If missing it is set to \nUInt64\n.\n\n\nmethod\n is one of the \nPCGMethod\n. If missing it is set to \nPCG_XSH_RS\n.\n\n\nSee \nPCG_LIST\n for the available parameter combinations.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.PCGStateSetseq\n \n \nType\n.\n\n\nPCGStateSetseq\n{\nStateType\n:\nPCGUInt\n,\n \nMethodType\n:\nPCGMethod\n,\n \nOutputType\n:\nPCGUInt\n}\n \n:\n\n    \nAbstractPCG\n{\nStateType\n,\n \nMethodType\n,\n \nOutputType\n}\n\n\nPCGStateSetseq\n([\nseed\n])\n\n\nPCGStateSetseq\n(\noutput_type\n[,\n \nseed\n])\n\n\nPCGStateSetseq\n(\nmethod\n[,\n \nseed\n])\n\n\nPCGStateSetseq\n(\noutput_type\n[,\n \nmethod\n,\n \nseed\n])\n\n\n\n\n\n\nPCG generator with \nspecific streams\n, where the constant can be changed at any time, selecting a different random sequence.\n\n\nseed\n is a \nTuple\n of two \nInteger\ns which will both be automatically converted to the state type.\n\n\noutput_type\n is the type of the PCG's output. If missing it is set to \nUInt64\n.\n\n\nmethod\n is one of the \nPCGMethod\n. If missing it is set to \nPCG_XSH_RS\n.\n\n\nSee \nPCG_LIST\n for the available parameter combinations.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.PCGStateUnique\n \n \nType\n.\n\n\nPCGStateUnique\n{\nStateType\n:\nPCGUInt\n,\n \nMethodType\n:\nPCGMethod\n,\n \nOutputType\n:\nPCGUInt\n}\n \n:\n\n    \nAbstractPCG\n{\nStateType\n,\n \nMethodType\n,\n \nOutputType\n}\n\n\nPCGStateUnique\n([\nseed\n])\n\n\nPCGStateUnique\n(\noutput_type\n[,\n \nseed\n])\n\n\nPCGStateUnique\n(\nmethod\n[,\n \nseed\n])\n\n\nPCGStateUnique\n(\noutput_type\n[,\n \nmethod\n,\n \nseed\n])\n\n\n\n\n\n\nPCG generator with \nunique streams\n, where the constant is based on the memory address of the object, thus every RNG has its own unique sequence.\n\n\nseed\n is an \nInteger\n which will be automatically converted to the state type.\n\n\noutput_type\n is the type of the PCG's output. If missing it is set to \nUInt64\n.\n\n\nmethod\n is one of the \nPCGMethod\n. If missing it is set to \nPCG_XSH_RS\n.\n\n\nSee \nPCG_LIST\n for the available parameter combinations.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.advance!\n \n \nMethod\n.\n\n\nadvance!\n(\nr\n,\n \n\u0394\n)\n\n\n\n\n\n\nAdvance a PCG object \nr\n for \n\u0394\n steps.\n\n\nExamples\n\n\njulia\n \nr\n \n=\n \nPCGStateSetseq\n(\nUInt64\n,\n \nPCG_RXS_M_XS\n,\n \n(\n123\n,\n \n321\n))\n\n\nRNG.PCG.PCGStateSetseq{UInt64,Val{:RXS_M_XS},UInt64}(0x45389f8b27528b29,0x0000000000000283)\n\n\n\njulia\n \nA\n \n=\n \nrand\n(\nr\n,\n \nUInt64\n,\n \n2\n);\n\n\n\njulia\n \np\n \n=\n \nrand\n(\nr\n);\n\n\n\njulia\n \nr\n\n\nRNG.PCG.PCGStateSetseq{UInt64,Val{:RXS_M_XS},UInt64}(0x9b1fc763ae0ad702,0x0000000000000283)\n\n\n\njulia\n \nadvance!\n(\nr\n,\n \n-\n3\n)\n\n\nRNG.PCG.PCGStateSetseq{UInt64,Val{:RXS_M_XS},UInt64}(0x45389f8b27528b29,0x0000000000000283)\n\n\n\njulia\n \n@\nTest\n.\ntest\n \nA\n \n==\n \nrand\n(\nr\n,\n \nUInt64\n,\n \n2\n)\n\n\nTest Passed\n\n\n  Expression: A == rand(r,UInt64,2)\n\n\n   Evaluated: UInt64[0x245806d421c0d835,0x5b6bc4b066eda37f] == UInt64[0x245806d421c0d835,0x5b6bc4b066eda37f]\n\n\n\njulia\n \n@\nTest\n.\ntest\n \np\n \n==\n \nrand\n(\nr\n)\n\n\nTest Passed\n\n\n  Expression: p == rand(r)\n\n\n   Evaluated: 0.3950038072091506 == 0.3950038072091506\n\n\n\n\n\n\nsource\n\n\n#\n\n\nRNG.PCG.bounded_rand\n \n \nMethod\n.\n\n\nbounded_rand\n(\nr\n,\n \nbound\n)\n\n\n\n\n\n\nProducing a random number less than a given \nbound\n in the output type.\n\n\nsource\n\n\n\n\nInternal\n\n\n#\n\n\nRNG.PCG.AbstractPCG\n \n \nType\n.\n\n\nAbstractPCG\n{\nStateType\n:\nPCGUInt\n,\n \nMethodType\n:\nPCGMethod\n,\n \nOutputType\n:\nPCGUInt\n}\n \n:\n \nAbstractRNG\n{\nOutputType\n}\n\n\n\n\n\n\nThe base abstract type for PCGs.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.default_increment\n \n \nMethod\n.\n\n\nReturn the default increment for a certain type.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.default_multiplier\n \n \nMethod\n.\n\n\nReturn the default multiplier for a certain type.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.mcg_multiplier\n \n \nMethod\n.\n\n\nReturn the default MCG multiplier for a certain type.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.mcg_unmultiplier\n \n \nMethod\n.\n\n\nReturn the default MCG unmultiplier for a certain type.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.pcg_advance!\n \n \nFunction\n.\n\n\nAdvance a PCG object.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.pcg_advance_lcg\n \n \nMethod\n.\n\n\nGeneral advance functions.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.pcg_output\n \n \nFunction\n.\n\n\nReturn the output of a state for a certain PCG type.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.pcg_srand\n \n \nFunction\n.\n\n\nInitialize a PCG object.\n\n\nsource\n\n\n#\n\n\nRNG.PCG.pcg_step!\n \n \nFunction\n.\n\n\nDo one iteration step for a PCG object.\n\n\nsource", 
            "title": "PCG"
        }, 
        {
            "location": "/lib/pcg/#pcg", 
            "text": "", 
            "title": "PCG"
        }, 
        {
            "location": "/lib/pcg/#index", 
            "text": "RNG.PCG  RNG.PCG.PCGMethod  RNG.PCG.PCG_LIST  RNG.PCG.AbstractPCG  RNG.PCG.PCGStateMCG  RNG.PCG.PCGStateOneseq  RNG.PCG.PCGStateSetseq  RNG.PCG.PCGStateUnique  RNG.PCG.advance!  RNG.PCG.bounded_rand  RNG.PCG.default_increment  RNG.PCG.default_multiplier  RNG.PCG.mcg_multiplier  RNG.PCG.mcg_unmultiplier  RNG.PCG.pcg_advance!  RNG.PCG.pcg_advance_lcg  RNG.PCG.pcg_output  RNG.PCG.pcg_srand  RNG.PCG.pcg_step!", 
            "title": "Index"
        }, 
        {
            "location": "/lib/pcg/#public", 
            "text": "#  RNG.PCG     Module .  The module for  PCG Family .  source  #  RNG.PCG.PCGMethod     Constant .  The  Union  of all the PCG method types:  PCG_XSH_RS ,  PCG_XSH_RR ,  PCG_RXS_M_XS ,  PCG_XSL_RR , and  PCG_XSL_RR_RR .  source  #  RNG.PCG.PCG_LIST     Constant .  The list of all the parameter combinations that can be used for PCG.     Stream variation  State Type  Method Type  Output Type      PCGStateOneseq  UInt16  PCG_XSH_RS  UInt8    PCGStateOneseq  UInt32  PCG_XSH_RS  UInt16    PCGStateOneseq  UInt64  PCG_XSH_RS  UInt32    PCGStateOneseq  UInt128  PCG_XSH_RS  UInt64    PCGStateUnique  UInt16  PCG_XSH_RS  UInt8    PCGStateUnique  UInt32  PCG_XSH_RS  UInt16    PCGStateUnique  UInt64  PCG_XSH_RS  UInt32    PCGStateUnique  UInt128  PCG_XSH_RS  UInt64    PCGStateSetseq  UInt16  PCG_XSH_RS  UInt8    PCGStateSetseq  UInt32  PCG_XSH_RS  UInt16    PCGStateSetseq  UInt64  PCG_XSH_RS  UInt32    PCGStateSetseq  UInt128  PCG_XSH_RS  UInt64    PCGStateMCG  UInt16  PCG_XSH_RS  UInt8    PCGStateMCG  UInt32  PCG_XSH_RS  UInt16    PCGStateMCG  UInt64  PCG_XSH_RS  UInt32    PCGStateMCG  UInt128  PCG_XSH_RS  UInt64    PCGStateOneseq  UInt16  PCG_XSH_RR  UInt8    PCGStateOneseq  UInt32  PCG_XSH_RR  UInt16    PCGStateOneseq  UInt64  PCG_XSH_RR  UInt32    PCGStateOneseq  UInt128  PCG_XSH_RR  UInt64    PCGStateUnique  UInt16  PCG_XSH_RR  UInt8    PCGStateUnique  UInt32  PCG_XSH_RR  UInt16    PCGStateUnique  UInt64  PCG_XSH_RR  UInt32    PCGStateUnique  UInt128  PCG_XSH_RR  UInt64    PCGStateSetseq  UInt16  PCG_XSH_RR  UInt8    PCGStateSetseq  UInt32  PCG_XSH_RR  UInt16    PCGStateSetseq  UInt64  PCG_XSH_RR  UInt32    PCGStateSetseq  UInt128  PCG_XSH_RR  UInt64    PCGStateMCG  UInt16  PCG_XSH_RR  UInt8    PCGStateMCG  UInt32  PCG_XSH_RR  UInt16    PCGStateMCG  UInt64  PCG_XSH_RR  UInt32    PCGStateMCG  UInt128  PCG_XSH_RR  UInt64    PCGStateOneseq  UInt8  PCG_RXS_M_XS  UInt8    PCGStateOneseq  UInt16  PCG_RXS_M_XS  UInt16    PCGStateOneseq  UInt32  PCG_RXS_M_XS  UInt32    PCGStateOneseq  UInt64  PCG_RXS_M_XS  UInt64    PCGStateOneseq  UInt128  PCG_RXS_M_XS  UInt128    PCGStateUnique  UInt16  PCG_RXS_M_XS  UInt16    PCGStateUnique  UInt32  PCG_RXS_M_XS  UInt32    PCGStateUnique  UInt64  PCG_RXS_M_XS  UInt64    PCGStateUnique  UInt128  PCG_RXS_M_XS  UInt128    PCGStateSetseq  UInt8  PCG_RXS_M_XS  UInt8    PCGStateSetseq  UInt16  PCG_RXS_M_XS  UInt16    PCGStateSetseq  UInt32  PCG_RXS_M_XS  UInt32    PCGStateSetseq  UInt64  PCG_RXS_M_XS  UInt64    PCGStateSetseq  UInt128  PCG_RXS_M_XS  UInt128    PCGStateOneseq  UInt64  PCG_XSL_RR  UInt32    PCGStateOneseq  UInt128  PCG_XSL_RR  UInt64    PCGStateUnique  UInt64  PCG_XSL_RR  UInt32    PCGStateUnique  UInt128  PCG_XSL_RR  UInt64    PCGStateSetseq  UInt64  PCG_XSL_RR  UInt32    PCGStateSetseq  UInt128  PCG_XSL_RR  UInt64    PCGStateMCG  UInt64  PCG_XSL_RR  UInt32    PCGStateMCG  UInt128  PCG_XSL_RR  UInt64    PCGStateOneseq  UInt64  PCG_XSL_RR_RR  UInt64    PCGStateOneseq  UInt128  PCG_XSL_RR_RR  UInt128    PCGStateUnique  UInt64  PCG_XSL_RR_RR  UInt64    PCGStateUnique  UInt128  PCG_XSL_RR_RR  UInt128    PCGStateSetseq  UInt64  PCG_XSL_RR_RR  UInt64    PCGStateSetseq  UInt128  PCG_XSL_RR_RR  UInt128     source  #  RNG.PCG.PCGStateMCG     Type .  PCGStateMCG { StateType : PCGUInt ,   MethodType : PCGMethod ,   OutputType : PCGUInt }   : \n     AbstractPCG { StateType ,   MethodType ,   OutputType }  PCGStateMCG ([ seed ])  PCGStateMCG ( output_type [,   seed ])  PCGStateMCG ( method [,   seed ])  PCGStateMCG ( output_type [,   method ,   seed ])   PCG generator with  MCG , where the increment is zero, resulting in a single stream and reduced period.  seed  is an  Integer  which will be automatically converted to the state type.  output_type  is the type of the PCG's output. If missing it is set to  UInt64 .  method  is one of the  PCGMethod . If missing it is set to  PCG_XSH_RS .  See  PCG_LIST  for the available parameter combinations.  source  #  RNG.PCG.PCGStateOneseq     Type .  PCGStateOneseq { StateType : PCGUInt ,   MethodType : PCGMethod ,   OutputType : PCGUInt }   : \n     AbstractPCG { StateType ,   MethodType ,   OutputType }  PCGStateOneseq ([ seed ])  PCGStateOneseq ( output_type [,   seed ])  PCGStateOneseq ( method [,   seed ])  PCGStateOneseq ( output_type [,   method ,   seed ])   PCG generator with  single streams , where all instances use the same fixed constant, thus the RNG always somewhere in same sequence.  seed  is an  Integer  which will be automatically converted to the state type.  output_type  is the type of the PCG's output. If missing it is set to  UInt64 .  method  is one of the  PCGMethod . If missing it is set to  PCG_XSH_RS .  See  PCG_LIST  for the available parameter combinations.  source  #  RNG.PCG.PCGStateSetseq     Type .  PCGStateSetseq { StateType : PCGUInt ,   MethodType : PCGMethod ,   OutputType : PCGUInt }   : \n     AbstractPCG { StateType ,   MethodType ,   OutputType }  PCGStateSetseq ([ seed ])  PCGStateSetseq ( output_type [,   seed ])  PCGStateSetseq ( method [,   seed ])  PCGStateSetseq ( output_type [,   method ,   seed ])   PCG generator with  specific streams , where the constant can be changed at any time, selecting a different random sequence.  seed  is a  Tuple  of two  Integer s which will both be automatically converted to the state type.  output_type  is the type of the PCG's output. If missing it is set to  UInt64 .  method  is one of the  PCGMethod . If missing it is set to  PCG_XSH_RS .  See  PCG_LIST  for the available parameter combinations.  source  #  RNG.PCG.PCGStateUnique     Type .  PCGStateUnique { StateType : PCGUInt ,   MethodType : PCGMethod ,   OutputType : PCGUInt }   : \n     AbstractPCG { StateType ,   MethodType ,   OutputType }  PCGStateUnique ([ seed ])  PCGStateUnique ( output_type [,   seed ])  PCGStateUnique ( method [,   seed ])  PCGStateUnique ( output_type [,   method ,   seed ])   PCG generator with  unique streams , where the constant is based on the memory address of the object, thus every RNG has its own unique sequence.  seed  is an  Integer  which will be automatically converted to the state type.  output_type  is the type of the PCG's output. If missing it is set to  UInt64 .  method  is one of the  PCGMethod . If missing it is set to  PCG_XSH_RS .  See  PCG_LIST  for the available parameter combinations.  source  #  RNG.PCG.advance!     Method .  advance! ( r ,   \u0394 )   Advance a PCG object  r  for  \u0394  steps.  Examples  julia   r   =   PCGStateSetseq ( UInt64 ,   PCG_RXS_M_XS ,   ( 123 ,   321 ))  RNG.PCG.PCGStateSetseq{UInt64,Val{:RXS_M_XS},UInt64}(0x45389f8b27528b29,0x0000000000000283)  julia   A   =   rand ( r ,   UInt64 ,   2 );  julia   p   =   rand ( r );  julia   r  RNG.PCG.PCGStateSetseq{UInt64,Val{:RXS_M_XS},UInt64}(0x9b1fc763ae0ad702,0x0000000000000283)  julia   advance! ( r ,   - 3 )  RNG.PCG.PCGStateSetseq{UInt64,Val{:RXS_M_XS},UInt64}(0x45389f8b27528b29,0x0000000000000283)  julia   @ Test . test   A   ==   rand ( r ,   UInt64 ,   2 )  Test Passed    Expression: A == rand(r,UInt64,2)     Evaluated: UInt64[0x245806d421c0d835,0x5b6bc4b066eda37f] == UInt64[0x245806d421c0d835,0x5b6bc4b066eda37f]  julia   @ Test . test   p   ==   rand ( r )  Test Passed    Expression: p == rand(r)     Evaluated: 0.3950038072091506 == 0.3950038072091506   source  #  RNG.PCG.bounded_rand     Method .  bounded_rand ( r ,   bound )   Producing a random number less than a given  bound  in the output type.  source", 
            "title": "Public"
        }, 
        {
            "location": "/lib/pcg/#internal", 
            "text": "#  RNG.PCG.AbstractPCG     Type .  AbstractPCG { StateType : PCGUInt ,   MethodType : PCGMethod ,   OutputType : PCGUInt }   :   AbstractRNG { OutputType }   The base abstract type for PCGs.  source  #  RNG.PCG.default_increment     Method .  Return the default increment for a certain type.  source  #  RNG.PCG.default_multiplier     Method .  Return the default multiplier for a certain type.  source  #  RNG.PCG.mcg_multiplier     Method .  Return the default MCG multiplier for a certain type.  source  #  RNG.PCG.mcg_unmultiplier     Method .  Return the default MCG unmultiplier for a certain type.  source  #  RNG.PCG.pcg_advance!     Function .  Advance a PCG object.  source  #  RNG.PCG.pcg_advance_lcg     Method .  General advance functions.  source  #  RNG.PCG.pcg_output     Function .  Return the output of a state for a certain PCG type.  source  #  RNG.PCG.pcg_srand     Function .  Initialize a PCG object.  source  #  RNG.PCG.pcg_step!     Function .  Do one iteration step for a PCG object.  source", 
            "title": "Internal"
        }, 
        {
            "location": "/lib/mersenne-twisters/", 
            "text": "MersenneTwisters\n\n\n\n\nIndex\n\n\n\n\nRNG.MersenneTwisters\n\n\nRNG.MersenneTwisters.MT19937\n\n\nRNG.MersenneTwisters.MersenneTwister\n\n\nRNG.MersenneTwisters.mt_get\n\n\nRNG.MersenneTwisters.mt_set!\n\n\nRNG.MersenneTwisters.mt_set!\n\n\n\n\n\n\nPublic\n\n\n#\n\n\nRNG.MersenneTwisters\n \n \nModule\n.\n\n\nThe module for \nMersenne Twisters\n.\n\n\nCurrently only provide one RNG type:\n\n\n\n\nMT19937\n\n\n\n\nsource\n\n\n#\n\n\nRNG.MersenneTwisters.MT19937\n \n \nType\n.\n\n\nMT19937\n \n:\n \nMersenneTwister\n{\nUInt32\n}\n\n\nMT19937\n([\nseed\n])\n\n\n\n\n\n\nMT19937 RNG. The \nseed\n is a \nTuple\n of 624 \nUInt32\n numbers, or an \nInteger\n which will be automatically convert to an \nUInt32\n number.\n\n\nsource\n\n\n\n\nInternal\n\n\n#\n\n\nRNG.MersenneTwisters.MersenneTwister\n \n \nType\n.\n\n\nMersenneTwister\n{\nT\n}\n \n:\n \nRNG\n.\nAbstractRNG\n{\nT\n}\n\n\n\n\n\n\nThe base type of Mersenne Twisters.\n\n\nsource\n\n\n#\n\n\nRNG.MersenneTwisters.mt_get\n \n \nMethod\n.\n\n\nGet a random \nUInt32\n number from a \nMT19937\n object.\n\n\nsource\n\n\n#\n\n\nRNG.MersenneTwisters.mt_set!\n \n \nMethod\n.\n\n\nSet up a \nMT19937\n RNG object using a \nTuple\n of 624 \nUInt32\n numbers.\n\n\nsource\n\n\n#\n\n\nRNG.MersenneTwisters.mt_set!\n \n \nMethod\n.\n\n\nSet up a \nMT19937\n RNG object using an \nUInt32\n number.\n\n\nsource", 
            "title": "MersenneTwisters"
        }, 
        {
            "location": "/lib/mersenne-twisters/#mersennetwisters", 
            "text": "", 
            "title": "MersenneTwisters"
        }, 
        {
            "location": "/lib/mersenne-twisters/#index", 
            "text": "RNG.MersenneTwisters  RNG.MersenneTwisters.MT19937  RNG.MersenneTwisters.MersenneTwister  RNG.MersenneTwisters.mt_get  RNG.MersenneTwisters.mt_set!  RNG.MersenneTwisters.mt_set!", 
            "title": "Index"
        }, 
        {
            "location": "/lib/mersenne-twisters/#public", 
            "text": "#  RNG.MersenneTwisters     Module .  The module for  Mersenne Twisters .  Currently only provide one RNG type:   MT19937   source  #  RNG.MersenneTwisters.MT19937     Type .  MT19937   :   MersenneTwister { UInt32 }  MT19937 ([ seed ])   MT19937 RNG. The  seed  is a  Tuple  of 624  UInt32  numbers, or an  Integer  which will be automatically convert to an  UInt32  number.  source", 
            "title": "Public"
        }, 
        {
            "location": "/lib/mersenne-twisters/#internal", 
            "text": "#  RNG.MersenneTwisters.MersenneTwister     Type .  MersenneTwister { T }   :   RNG . AbstractRNG { T }   The base type of Mersenne Twisters.  source  #  RNG.MersenneTwisters.mt_get     Method .  Get a random  UInt32  number from a  MT19937  object.  source  #  RNG.MersenneTwisters.mt_set!     Method .  Set up a  MT19937  RNG object using a  Tuple  of 624  UInt32  numbers.  source  #  RNG.MersenneTwisters.mt_set!     Method .  Set up a  MT19937  RNG object using an  UInt32  number.  source", 
            "title": "Internal"
        }, 
        {
            "location": "/lib/random123/", 
            "text": "Random123\n\n\n\n\nIndex\n\n\n\n\nRNG.Random123\n\n\nRNG.Random123.R123_USE_AESNI\n\n\nRNG.Random123.AbstractR123\n\n\nRNG.Random123.Philox2x\n\n\nRNG.Random123.Philox4x\n\n\nRNG.Random123.R123Generator1x\n\n\nRNG.Random123.R123Generator2x\n\n\nRNG.Random123.R123Generator4x\n\n\nRNG.Random123.Threefry2x\n\n\nRNG.Random123.Threefry4x\n\n\nRNG.Random123.random123_r\n\n\n\n\n\n\nPublic\n\n\n#\n\n\nRNG.Random123\n \n \nModule\n.\n\n\nThe module for \nRandom123 Family\n.\n\n\nProvide 8 RNG types:\n\n\n\n\nThreefry2x\n\n\nThreefry4x\n\n\nPhilox2x\n\n\nPhilox4x\n\n\nAESNI1x\n\n\nAESNI4x\n\n\nARS1x\n\n\nARS4x\n\n\n\n\nsource\n\n\n#\n\n\nRNG.Random123.R123_USE_AESNI\n \n \nConstant\n.\n\n\nTrue when AES-NI library has been compiled.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.Philox2x\n \n \nType\n.\n\n\nPhilox2x\n{\nT\n,\n \nR\n}\n \n:\n \nR123Generator2x\n{\nT\n}\n\n\nPhilox2x\n([\nseed\n,\n \nR\n])\n\n\nPhilox2x\n(\nT\n[,\n \nseed\n,\n \nR\n])\n\n\n\n\n\n\nPhilox2x is one kind of Philox Counter-Based RNGs. It generates two numbers at a time.\n\n\nT\n is \nUInt32\n or \nUInt64\n(default).\n\n\nseed\n is an \nInteger\n which will be automatically converted to \nT\n.\n\n\nR\n denotes to the Rounds. With 10 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.Philox4x\n \n \nType\n.\n\n\nPhilox4x\n{\nT\n,\n \nR\n}\n \n:\n \nR123Generator4x\n{\nT\n}\n\n\nPhilox4x\n([\nseed\n,\n \nR\n])\n\n\nPhilox4x\n(\nT\n[,\n \nseed\n,\n \nR\n])\n\n\n\n\n\n\nPhilox4x is one kind of Philox Counter-Based RNGs. It generates four numbers at a time.\n\n\nT\n is \nUInt32\n or \nUInt64\n(default).\n\n\nseed\n is a \nTuple\n of two \nInteger\ns which will both be automatically converted to \nT\n.\n\n\nR\n denotes to the Rounds. With 10 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.Threefry2x\n \n \nType\n.\n\n\nThreefry2x\n{\nT\n,\n \nR\n}\n \n:\n \nR123Generator2x\n{\nT\n}\n\n\nThreefry2x\n([\nseed\n,\n \nR\n])\n\n\nThreefry2x\n(\nT\n[,\n \nseed\n,\n \nR\n])\n\n\n\n\n\n\nThreefry2x is one kind of Threefry Counter-Based RNGs. It generates two numbers at a time.\n\n\nT\n is \nUInt32\n or \nUInt64\n(default).\n\n\nseed\n is a \nTuple\n of two \nInteger\ns which will both be automatically converted to \nT\n.\n\n\nR\n denotes to the Rounds. With 20 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.Threefry4x\n \n \nType\n.\n\n\nThreefry4x\n{\nT\n,\n \nR\n}\n \n:\n \nR123Generator4x\n{\nT\n}\n\n\nThreefry4x\n([\nseed\n,\n \nR\n])\n\n\nThreefry4x\n(\nT\n[,\n \nseed\n,\n \nR\n])\n\n\n\n\n\n\nThreefry2x is one kind of Threefry Counter-Based RNGs. It generates four numbers at a time.\n\n\nT\n is \nUInt32\n or \nUInt64\n(default).\n\n\nseed\n is a \nTuple\n of four \nInteger\ns which will all be automatically converted to \nT\n.\n\n\nR\n denotes to the Rounds. With 20 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.\n\n\nsource\n\n\n\n\nInternal\n\n\n#\n\n\nRNG.Random123.AbstractR123\n \n \nType\n.\n\n\nThe base abstract type for RNGs in \nRandom123 Family\n.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.R123Generator1x\n \n \nType\n.\n\n\nRNG that generates one number at a time.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.R123Generator2x\n \n \nType\n.\n\n\nRNG that generates two numbers at a time.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.R123Generator4x\n \n \nType\n.\n\n\nRNG that generates four numbers at a time.\n\n\nsource\n\n\n#\n\n\nRNG.Random123.random123_r\n \n \nFunction\n.\n\n\nDo one iteration and return the a tuple of a Random123 RNG object.\n\n\nsource", 
            "title": "Random123"
        }, 
        {
            "location": "/lib/random123/#random123", 
            "text": "", 
            "title": "Random123"
        }, 
        {
            "location": "/lib/random123/#index", 
            "text": "RNG.Random123  RNG.Random123.R123_USE_AESNI  RNG.Random123.AbstractR123  RNG.Random123.Philox2x  RNG.Random123.Philox4x  RNG.Random123.R123Generator1x  RNG.Random123.R123Generator2x  RNG.Random123.R123Generator4x  RNG.Random123.Threefry2x  RNG.Random123.Threefry4x  RNG.Random123.random123_r", 
            "title": "Index"
        }, 
        {
            "location": "/lib/random123/#public", 
            "text": "#  RNG.Random123     Module .  The module for  Random123 Family .  Provide 8 RNG types:   Threefry2x  Threefry4x  Philox2x  Philox4x  AESNI1x  AESNI4x  ARS1x  ARS4x   source  #  RNG.Random123.R123_USE_AESNI     Constant .  True when AES-NI library has been compiled.  source  #  RNG.Random123.Philox2x     Type .  Philox2x { T ,   R }   :   R123Generator2x { T }  Philox2x ([ seed ,   R ])  Philox2x ( T [,   seed ,   R ])   Philox2x is one kind of Philox Counter-Based RNGs. It generates two numbers at a time.  T  is  UInt32  or  UInt64 (default).  seed  is an  Integer  which will be automatically converted to  T .  R  denotes to the Rounds. With 10 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.  source  #  RNG.Random123.Philox4x     Type .  Philox4x { T ,   R }   :   R123Generator4x { T }  Philox4x ([ seed ,   R ])  Philox4x ( T [,   seed ,   R ])   Philox4x is one kind of Philox Counter-Based RNGs. It generates four numbers at a time.  T  is  UInt32  or  UInt64 (default).  seed  is a  Tuple  of two  Integer s which will both be automatically converted to  T .  R  denotes to the Rounds. With 10 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.  source  #  RNG.Random123.Threefry2x     Type .  Threefry2x { T ,   R }   :   R123Generator2x { T }  Threefry2x ([ seed ,   R ])  Threefry2x ( T [,   seed ,   R ])   Threefry2x is one kind of Threefry Counter-Based RNGs. It generates two numbers at a time.  T  is  UInt32  or  UInt64 (default).  seed  is a  Tuple  of two  Integer s which will both be automatically converted to  T .  R  denotes to the Rounds. With 20 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.  source  #  RNG.Random123.Threefry4x     Type .  Threefry4x { T ,   R }   :   R123Generator4x { T }  Threefry4x ([ seed ,   R ])  Threefry4x ( T [,   seed ,   R ])   Threefry2x is one kind of Threefry Counter-Based RNGs. It generates four numbers at a time.  T  is  UInt32  or  UInt64 (default).  seed  is a  Tuple  of four  Integer s which will all be automatically converted to  T .  R  denotes to the Rounds. With 20 rounds (by default), it has a considerable safety margin over the minimum number of rounds with no known statistical flaws, but still has excellent performance.  source", 
            "title": "Public"
        }, 
        {
            "location": "/lib/random123/#internal", 
            "text": "#  RNG.Random123.AbstractR123     Type .  The base abstract type for RNGs in  Random123 Family .  source  #  RNG.Random123.R123Generator1x     Type .  RNG that generates one number at a time.  source  #  RNG.Random123.R123Generator2x     Type .  RNG that generates two numbers at a time.  source  #  RNG.Random123.R123Generator4x     Type .  RNG that generates four numbers at a time.  source  #  RNG.Random123.random123_r     Function .  Do one iteration and return the a tuple of a Random123 RNG object.  source", 
            "title": "Internal"
        }, 
        {
            "location": "/lib/xorshifts/", 
            "text": "Xorshifts\n\n\n\n\nIndex\n\n\n\n\nRNG.Xorshifts\n\n\nRNG.Xorshifts.AbstractXoroshiro128\n\n\nRNG.Xorshifts.AbstractXorshift1024\n\n\nRNG.Xorshifts.AbstractXorshift128\n\n\nRNG.Xorshifts.AbstractXorshift64\n\n\nRNG.Xorshifts.Xoroshiro128\n\n\nRNG.Xorshifts.Xoroshiro128Plus\n\n\nRNG.Xorshifts.Xoroshiro128Star\n\n\nRNG.Xorshifts.Xorshift1024\n\n\nRNG.Xorshifts.Xorshift1024Plus\n\n\nRNG.Xorshifts.Xorshift1024Star\n\n\nRNG.Xorshifts.Xorshift128\n\n\nRNG.Xorshifts.Xorshift128Plus\n\n\nRNG.Xorshifts.Xorshift128Star\n\n\nRNG.Xorshifts.Xorshift64\n\n\nRNG.Xorshifts.Xorshift64Star\n\n\nRNG.Xorshifts.xorshift_next\n\n\n\n\n\n\nPublic\n\n\n#\n\n\nRNG.Xorshifts\n \n \nModule\n.\n\n\nThe module for \nXorshift Family\n.\n\n\nProvide 11 RNG types:\n\n\n\n\nXorshift64\n\n\nXorshift64Star\n\n\nXorshift128\n\n\nXorshift128Star\n\n\nXorshift128Plus\n\n\nXorshift1024\n\n\nXorshift1024Star\n\n\nXorshift1024Plus\n\n\nXoroshiro128\n\n\nXoroshiro128Star\n\n\nXoroshiro128Plus\n\n\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xoroshiro128\n \n \nType\n.\n\n\nXoroshiro128\n{\nT\n}\n \n:\n \nAbstractXoroshiro128\n{\nT\n}\n\n\nXoroshiro128\n([\nseed\n])\n\n\n\n\n\n\nXoroshiro128 RNG. The \nseed\n can be a \nTuple\n of two \nUInt64\ns, or an \nInteger\n which will be automatically convert to an \nUInt128\n number.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xoroshiro128Plus\n \n \nType\n.\n\n\nXoroshiro128Plus\n{\nT\n}\n \n:\n \nAbstractXoroshiro128\n{\nT\n}\n\n\nXoroshiro128Plus\n([\nseed\n])\n\n\n\n\n\n\nXoroshiro128Plus RNG. The \nseed\n can be a \nTuple\n of two \nUInt64\ns, or an \nInteger\n which will be automatically convert to an \nUInt128\n number.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xoroshiro128Star\n \n \nType\n.\n\n\nXoroshiro128Star\n{\nT\n}\n \n:\n \nAbstractXoroshiro128\n{\nT\n}\n\n\nXoroshiro128Star\n([\nseed\n])\n\n\n\n\n\n\nXoroshiro128Star RNG. The \nseed\n can be a \nTuple\n of two \nUInt64\ns, or an \nInteger\n which will be automatically convert to an \nUInt128\n number.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xorshift1024\n \n \nType\n.\n\n\nXorshift1024\n{\nT\n}\n \n:\n \nAbstractXorshift1024\n{\nT\n}\n\n\nXorshift1024\n([\nseed\n...\n])\n\n\n\n\n\n\nXorshift1024 RNG. The \nseed\n can be a \nTuple\n of 16 \nUInt64\ns, or several (no more than 16) \nInteger\ns which will all be automatically converted to \nUInt64\n numbers.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xorshift1024Plus\n \n \nType\n.\n\n\nXorshift1024Plus\n{\nT\n}\n \n:\n \nAbstractXorshift1024\n{\nT\n}\n\n\nXorshift1024Plus\n([\nseed\n...\n])\n\n\n\n\n\n\nXorshift1024Plus RNG. The \nseed\n can be a \nTuple\n of 16 \nUInt64\ns, or several (no more than 16) \nInteger\ns which will all be automatically converted to \nUInt64\n numbers.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xorshift1024Star\n \n \nType\n.\n\n\nXorshift1024Star\n{\nT\n}\n \n:\n \nAbstractXorshift1024\n{\nT\n}\n\n\nXorshift1024Star\n([\nseed\n...\n])\n\n\n\n\n\n\nXorshift1024Star RNG. The \nseed\n can be a \nTuple\n of 16 \nUInt64\ns, or several (no more than 16) \nInteger\ns which will all be automatically converted to \nUInt64\n numbers.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xorshift128\n \n \nType\n.\n\n\nXorshift128\n{\nT\n}\n \n:\n \nAbstractXorshift128\n{\nT\n}\n\n\nXorshift128\n([\nseed\n])\n\n\n\n\n\n\nXorshift128 RNG. The \nseed\n can be a \nTuple\n of two \nUInt64\ns, or an \nInteger\n which will be automatically convert to an \nUInt128\n number.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xorshift128Plus\n \n \nType\n.\n\n\nXorshift128Plus\n{\nT\n}\n \n:\n \nAbstractXorshift128\n{\nT\n}\n\n\nXorshift128Plus\n([\nseed\n])\n\n\n\n\n\n\nXorshift128Plus RNG. The \nseed\n can be a \nTuple\n of two \nUInt64\ns, or an \nInteger\n which will be automatically convert to an \nUInt128\n number.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xorshift128Star\n \n \nType\n.\n\n\nXorshift128Star\n{\nT\n}\n \n:\n \nAbstractXorshift128\n{\nT\n}\n\n\nXorshift128Star\n([\nseed\n])\n\n\n\n\n\n\nXorshift128Star RNG. The \nseed\n can be a \nTuple\n of two \nUInt64\ns, or an \nInteger\n which will be automatically convert to an \nUInt128\n number.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xorshift64\n \n \nType\n.\n\n\nXorshift64\n{\nT\n}\n \n:\n \nAbstractXorshift64\n{\nT\n}\n\n\nXorshift64\n([\nseed\n])\n\n\n\n\n\n\nXorshift64 RNG. The \nseed\n will be automatically convert to an \nUInt64\n number.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.Xorshift64Star\n \n \nType\n.\n\n\nXorshift64Star\n{\nT\n}\n \n:\n \nAbstractXorshift64\n{\nT\n}\n\n\nXorshift64Star\n([\nseed\n])\n\n\n\n\n\n\nXorshift64Star RNG. The \nseed\n will be automatically convert to an \nUInt64\n number.\n\n\nsource\n\n\n\n\nInternal\n\n\n#\n\n\nRNG.Xorshifts.AbstractXoroshiro128\n \n \nType\n.\n\n\nAbstractXoroshiro128\n \n:\n \nAbstractRNG\n{\nUInt64\n}\n\n\n\n\n\n\nThe base abstract type for \nXoroshiro128\n, \nXoroshiro128Star\n and \nXoroshiro128Plus\n.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.AbstractXorshift1024\n \n \nType\n.\n\n\nAbstractXorshift1024\n \n:\n \nAbstractRNG\n{\nUInt64\n}\n\n\n\n\n\n\nThe base abstract type for \nXorshift1024\n, \nXorshift1024Star\n and \nXorshift1024Plus\n.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.AbstractXorshift128\n \n \nType\n.\n\n\nAbstractXorshift128\n \n:\n \nAbstractRNG\n{\nUInt64\n}\n\n\n\n\n\n\nThe base abstract type for \nXorshift128\n, \nXorshift128Star\n and \nXorshift128Plus\n.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.AbstractXorshift64\n \n \nType\n.\n\n\nAbstractXorshift64\n \n:\n \nAbstractRNG\n{\nUInt64\n}\n\n\n\n\n\n\nThe base abstract type for \nXorshift64\n and \nXorshift64Star\n.\n\n\nsource\n\n\n#\n\n\nRNG.Xorshifts.xorshift_next\n \n \nFunction\n.\n\n\nDo one iteration and get the current value of a Xorshift RNG object.\n\n\nsource", 
            "title": "Xorshifts"
        }, 
        {
            "location": "/lib/xorshifts/#xorshifts", 
            "text": "", 
            "title": "Xorshifts"
        }, 
        {
            "location": "/lib/xorshifts/#index", 
            "text": "RNG.Xorshifts  RNG.Xorshifts.AbstractXoroshiro128  RNG.Xorshifts.AbstractXorshift1024  RNG.Xorshifts.AbstractXorshift128  RNG.Xorshifts.AbstractXorshift64  RNG.Xorshifts.Xoroshiro128  RNG.Xorshifts.Xoroshiro128Plus  RNG.Xorshifts.Xoroshiro128Star  RNG.Xorshifts.Xorshift1024  RNG.Xorshifts.Xorshift1024Plus  RNG.Xorshifts.Xorshift1024Star  RNG.Xorshifts.Xorshift128  RNG.Xorshifts.Xorshift128Plus  RNG.Xorshifts.Xorshift128Star  RNG.Xorshifts.Xorshift64  RNG.Xorshifts.Xorshift64Star  RNG.Xorshifts.xorshift_next", 
            "title": "Index"
        }, 
        {
            "location": "/lib/xorshifts/#public", 
            "text": "#  RNG.Xorshifts     Module .  The module for  Xorshift Family .  Provide 11 RNG types:   Xorshift64  Xorshift64Star  Xorshift128  Xorshift128Star  Xorshift128Plus  Xorshift1024  Xorshift1024Star  Xorshift1024Plus  Xoroshiro128  Xoroshiro128Star  Xoroshiro128Plus   source  #  RNG.Xorshifts.Xoroshiro128     Type .  Xoroshiro128 { T }   :   AbstractXoroshiro128 { T }  Xoroshiro128 ([ seed ])   Xoroshiro128 RNG. The  seed  can be a  Tuple  of two  UInt64 s, or an  Integer  which will be automatically convert to an  UInt128  number.  source  #  RNG.Xorshifts.Xoroshiro128Plus     Type .  Xoroshiro128Plus { T }   :   AbstractXoroshiro128 { T }  Xoroshiro128Plus ([ seed ])   Xoroshiro128Plus RNG. The  seed  can be a  Tuple  of two  UInt64 s, or an  Integer  which will be automatically convert to an  UInt128  number.  source  #  RNG.Xorshifts.Xoroshiro128Star     Type .  Xoroshiro128Star { T }   :   AbstractXoroshiro128 { T }  Xoroshiro128Star ([ seed ])   Xoroshiro128Star RNG. The  seed  can be a  Tuple  of two  UInt64 s, or an  Integer  which will be automatically convert to an  UInt128  number.  source  #  RNG.Xorshifts.Xorshift1024     Type .  Xorshift1024 { T }   :   AbstractXorshift1024 { T }  Xorshift1024 ([ seed ... ])   Xorshift1024 RNG. The  seed  can be a  Tuple  of 16  UInt64 s, or several (no more than 16)  Integer s which will all be automatically converted to  UInt64  numbers.  source  #  RNG.Xorshifts.Xorshift1024Plus     Type .  Xorshift1024Plus { T }   :   AbstractXorshift1024 { T }  Xorshift1024Plus ([ seed ... ])   Xorshift1024Plus RNG. The  seed  can be a  Tuple  of 16  UInt64 s, or several (no more than 16)  Integer s which will all be automatically converted to  UInt64  numbers.  source  #  RNG.Xorshifts.Xorshift1024Star     Type .  Xorshift1024Star { T }   :   AbstractXorshift1024 { T }  Xorshift1024Star ([ seed ... ])   Xorshift1024Star RNG. The  seed  can be a  Tuple  of 16  UInt64 s, or several (no more than 16)  Integer s which will all be automatically converted to  UInt64  numbers.  source  #  RNG.Xorshifts.Xorshift128     Type .  Xorshift128 { T }   :   AbstractXorshift128 { T }  Xorshift128 ([ seed ])   Xorshift128 RNG. The  seed  can be a  Tuple  of two  UInt64 s, or an  Integer  which will be automatically convert to an  UInt128  number.  source  #  RNG.Xorshifts.Xorshift128Plus     Type .  Xorshift128Plus { T }   :   AbstractXorshift128 { T }  Xorshift128Plus ([ seed ])   Xorshift128Plus RNG. The  seed  can be a  Tuple  of two  UInt64 s, or an  Integer  which will be automatically convert to an  UInt128  number.  source  #  RNG.Xorshifts.Xorshift128Star     Type .  Xorshift128Star { T }   :   AbstractXorshift128 { T }  Xorshift128Star ([ seed ])   Xorshift128Star RNG. The  seed  can be a  Tuple  of two  UInt64 s, or an  Integer  which will be automatically convert to an  UInt128  number.  source  #  RNG.Xorshifts.Xorshift64     Type .  Xorshift64 { T }   :   AbstractXorshift64 { T }  Xorshift64 ([ seed ])   Xorshift64 RNG. The  seed  will be automatically convert to an  UInt64  number.  source  #  RNG.Xorshifts.Xorshift64Star     Type .  Xorshift64Star { T }   :   AbstractXorshift64 { T }  Xorshift64Star ([ seed ])   Xorshift64Star RNG. The  seed  will be automatically convert to an  UInt64  number.  source", 
            "title": "Public"
        }, 
        {
            "location": "/lib/xorshifts/#internal", 
            "text": "#  RNG.Xorshifts.AbstractXoroshiro128     Type .  AbstractXoroshiro128   :   AbstractRNG { UInt64 }   The base abstract type for  Xoroshiro128 ,  Xoroshiro128Star  and  Xoroshiro128Plus .  source  #  RNG.Xorshifts.AbstractXorshift1024     Type .  AbstractXorshift1024   :   AbstractRNG { UInt64 }   The base abstract type for  Xorshift1024 ,  Xorshift1024Star  and  Xorshift1024Plus .  source  #  RNG.Xorshifts.AbstractXorshift128     Type .  AbstractXorshift128   :   AbstractRNG { UInt64 }   The base abstract type for  Xorshift128 ,  Xorshift128Star  and  Xorshift128Plus .  source  #  RNG.Xorshifts.AbstractXorshift64     Type .  AbstractXorshift64   :   AbstractRNG { UInt64 }   The base abstract type for  Xorshift64  and  Xorshift64Star .  source  #  RNG.Xorshifts.xorshift_next     Function .  Do one iteration and get the current value of a Xorshift RNG object.  source", 
            "title": "Internal"
        }
    ]
}